# 2장 - 테스트

- 스프링이 제공하는 가장 중요한 가치는 객체지향과 테스트다.
- 애플리케이션은 계속 변하고 복잡해진다. 그 변화에 대응하기 위한 전략 2가지가 있다.
    - 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술
    - 만들어진 코드를 확신할 수 있게 해주고, 변화에 유연하게 대처할 수 있게 해주는 테스트 기술
        - 테스트는 스프링을 학습하는 데 있어 효과적인 방법의 하나다.
        - 테스트의 작성은 스프링의 다양한 기술을 활용하는 방법을 이해하고 검증하고, 실전에 적용하는 방법을 익히는 데 효과적으로 사용될 수 있다.

## 2.1 UserDaoTest 다시보기

### 2.1.1 테스트의 유용성

- 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인하는 작업

### 2.1.2 `UserDaoTest`의 특징

- `main()` 메서드를 통해 `UserDao`의 메서드를 직접 호출하고, 테스트 결과를 콘솔에 출력하는 방식이다.
- 웹을 통한 DAO 테스트 방법의 문제점
    - 보통 웹 애플리케이션 테스트 방식
        - DAO, Service, MVC 프레젠테이션 계층까지 모두 만든다.
        - 테스트용 웹 애플리케이션을 서버에 배치한다.
        - 웹 화면을 띄워 폼을 열고, 값을 입력한 뒤 버튼을 눌러 등록해 본다.
        - 결과를 확인한다.
    - 이런 방식은 모든 계층을 다 만들고 나서야 테스트가 가능하다는 점이 가장 큰 문제다.
    - 테스트에 모든 계층이 참여하고 있기 때문에 어디에서 문제가 발생했는지 찾기 어렵다.
- 작은 단위의 테스트
    - 테스트하고자 하는 대상에만 집중하여 테스트 하는 것이 바람직하다.
    - 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(Unit Test)라고 한다.
        - `UserDao`라는 작은 단위의 기능만을 담당하는 `UserDaoTest`도 일종의 단위 테스트라고 볼 수 있다.
    - 전 과정이 참여하는 테스트도 필요하다.
        - 단위 테스트 없이 통합 테스트에서 오류가 난다면 문제의 원인을 찾기 매우 힘들다.
    - 단위 테스트는 작성한 코드가 정상 동작하는지 바른 검증을 받기 위해서도 필요하다.
- 자동수행 테스트 코드
    - 수동 테스트의 불편함을 해결할 수 있다.
        - 수동 테스트는 절차가 번거롭다.
        - 사람이 수동으로 테스트 결과를 판단하는 것은 실수할 가능성이 높다.
    - 번거롭지 않고, 빠르게 실행할 수 있기 때문에 자주 반복할 수 있다.
- 지속적인 개선과 점짐적인 개발을 위한 테스트
    - 변경 후 테스트를 통해 확인할 수 있기 때문에 코드를 개선해 나가는 것이 쉽다.

### 2.1.3 `UserDaoTest`의 문제점

- 수동 확인 작업의 번거로움
    - 사람이 테스트 수행 결과를 눈으로 확인해야 하는 과정이 필요하다.
- 실행 작업의 번거로움
    - 매번 `main()` 메서드를 실행하는 것이 번거롭다.
    - DAo가 늘어나면 `main()` 메서드도 늘어난다.

## 2.2 UserDaoTest 의 개선

### 2.2.1 테스트 검증의 자동화

- 모든 테스트의 결과
    - 성공
    - 실패
        - 에러 발생
        - 결과가 기대한 것과 다름
- 테스트 중 에러 발생은 쉽게 확인할 수 있다.
    - 콘솔에 에러 메시지와 호출 스택 정보가 출력된다.
- 테스트가 실패하는 것은 별도의 확인 작업과 그 결과가 있어야 확인할 수 있다.

### 2.2.2 테스트의 효율적인 수행과 결과 관리

- 자바로 단위 테스트를 위한 JUnit 프래임워크가 존재한다.
    - 일정한 패턴을 가진 테스트를 만들 수 있다.
    - 많은 테스트를 간단히 실행 가능하다.
    - 테스트 결과를 종합해서 볼수 있다.
    - 테스트가 실패한 곳을 빠르게 찾을 수 있다.

- JUnit 테스트 전환(소스 참고)
- 테스트 메서드 전환(소스 참고)
    - `@Test` 어노테이션을 통해 JUnit에게 테스트 메서드임을 명시
- 검증 코드 전환(소스 참고)
    - JUnit이 제공하는 AssertThat 스테틱 메소드 사용
- JUnit 테스트 실행
    - `JUnitCore` 클래스의 `main()` 메서드 호출
    - 테스트가 실패하면 OK 대신 FAILURES!!! 내용 출력
        - 실패한 원인과 위치를 확인할 수 있다.

## 2.3 개발자를 위한 테스팅 프레임워크 JUnit

- 스프링 프레임워크 자체도 JUnit 프레임워크를 이용해 테스트를 만들어가며 개발됐다.
- 스프링의 핵심 기능 중 하나인 스프링 테스트 모듈도 JUnit을 이용한다.

### 2.3.1 테스트 실행 방법

- IDE
    - `JUnitCore.main()` 만들지 않아도 바로 실행 가능하도록 지원한다.
- 빌드 툴
    - 비드 툴에서 제공하는 JUnit 플러그인이나 태스크를 통해 테스트를 실행할 수 있다.

### 2.3.2 테스트 결과의 일관성

- 현재 `UserDaoTest`은 테스트를 실행하기 전 DB의 USER 테이블 데이터를 모두 삭제해야 한다.
    - 그냥 테스트를 여러번 실행하면 기본키 중복으로 에러가 발생한다.
- 외부 상태에 따라 테스트 결과가 달라진다.
- 코드에 변경사항이 없다면 테스트는 항상 동일한 결과를 얻어야 한다.
- `deleteAll()`의 `getCount()` 추가(소스 참고)
- `deleteAll()`와 `getCount()`의 테스트(소스 참고)
    - `addAndGet()` 테스트 확장
- 동일한 결과를 보장하는 테스트
    - 단위 테스트는 항상 일관성 있는 결과가 보장되어야 한다.
    - 테스트 순서를 바꿔도 동일한 결과가 보장되도록 만들어야 한다.

### 2.3.3 포괄적인 테스트

- 새로 추가된 `deleteAll()`와 `getCount()` 각각의 검증 테스트를 작성한다.
- 성의 없는 테스트는 테스트를 만들지 않는 것 보다 더 위험하다.
- `getCount()` 테스트(소스 참고)
- `addAndGet()` 테스트 보완(소스 참고)
- `get()` 예외 조건에 대한 테스트
    - `get()` 메서드에 전달된 ID에 해당하는 사용자가 없는 경우
        - `null`과 같은 특정한 값 반환한다.
        - 해당 id 를 찾을 수 없다고 예외를 던진다.
            - 스프링의 `EmptyResultDataAccessExcepption` 예외를 이용
    - 검증을 위한 테스트 코드 작성(소스 참고)
        - JUnit은 예외조건 테스트를 위한 방법을 제공해준다.
        ```java
        @Test(expected = EmptyResultDataAccessException.class)
        ```
- 테스트를 성공시키기 위한 코드의 수정(소스 참고)
    - `get()` 메서드에 ID에 해당하는 데이터가 없으면  `EmptyResultDataAccessException`을 던지는 로직을 추가한다.
    - 3개의 테스트 모두 성공하면 새로 추가한 기능도 정상동작하고, 기존 기능에도 영향을 주지 않았다는 확신을 얻을 수 있다.
- 포괄적인 테스트
    - 포괄적인 테스트를 만들어두는 편이 안전하고 유용하다.
    - 그러나 개발자는 성공하는 테스트만 골라서 만드는 실수를 자주 한다.
    - 자신이 만든 코드에서 발생할 수 있는 다양한 상황과 입력 값을 고려하는 포괄적인 테스트를 만들어야 한다.
    - 테스트 작성할 때는 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

### 2.3.4 테스트가 이끄는 개발

- `get()` 메서드 예외 테스트 작성 과정
    - 테스트를 먼저 만들고 테스트가 실패하는 것을 보고 나서, `UserDao` 코드를 수정했다
- 기능설계를 위한 테스트
    - 테스트 할 코드가 없지만, 추가하고 싶은 기능을 코드로 표현하려고 했기 때문에 `getUserFailure()`를 만들 수 있었다.

|    | 단계          | 내용                       | 코드                                                            |
|----|-------------|--------------------------|---------------------------------------------------------------|
| 조건 | 어떤 조건을 가지고  | 가져오는 사용자 정보가 존재하지 않는 경우에 | userDao.deleteAll();<br/>assertEquals(0, userDao.getCount()); |
| 행위 | 무엇을 할때      | 존재하지 않는 id로 get() 을 실행하면 | get("unknown_id")                                             |
| 결과 | 어떤 결과가 나온다. | 특별한 예외가 던져진다.            | @Test(expected = EmptyResultDataAccessException.class)        |

- 비교해보면 테스트 코드는 잘 정의된 하나의 기능정의서로 보인다.
- 기능설계, 구현, 테스트의 개발 흐름 중 테스트 코드는 기능설계의 일부를 담당하고 있다.
- 테스트 주도 개발(TDD, Test Driven Development)
    - 테스트를 먼저 만들고, 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방법이다.
    - 테스트가 주는 장점을 극대화한 방법이다.
        - 코드를 만들어 테스트를 실행하는 그 사이의 간격이 매우 짧다.
        - 자연스럽게 단위 테스트를 만들 수 있다.

### 2.3.5 테스트 코드 개선

- 테스트 코드도 리팩토링의 대상이 된다.
- `UserDaoTest`에서 반복되는 부분을 별도의 메서드로 분리한다.
    ```java
    ApplicationContext applicationContext = new GenericXmlApplicationContext("/application-Context.xml");
    UserDao userDao = applicationContext.getBean("userDao", UserDao.class);
    ```
- `@Before`
    - JUnit이 하나의 테스트를 수행하는 방식
        1. 테스트 클래스에서 `@Test`가 붙은 `public`이고 `void`형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
        2. 테스트 클래스의 객체를 하나 만든다.
        3. `@Before`가 붙은 메소드가 있으면 실행한다.
        4. `@Test`가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
        5. `@After`가 붙은 메소드가 있으면 실행한다.
        6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
        7. 모든 테스트의 결과를 종합해서 돌려준다.
    - `@Before`는 모든 `@Test`가 붙은 메서드 실행 전 자동으로 실행한다.
    - JUnit은 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장하기 위해 매번 새로운 객체를 만든다.
- 픽스쳐(Fixture)
    - 테스트를 수행하는데 필요한 정보나 객체
    - 일반적으로 테스트에서 반복적으로 사용되기 때문에 `@Before`에 생성해 두면 편리하다.

## 2.4 스프링 테스트 적용

- 테스트 메서드가 실행 될 때 마다 스프링의 애플리케이션 컨텍스트도 매번 만들어진다.
    - 빈이 많아지고 의존관계가 복잡해지면 애플리케이션 컨텍스트 생성에 많은 시간이 소요될 수 있다.
    - 애플리케이션 컨텍스트가 초기화 할 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적인 스레드를 띄운다.
        - 빈이 할당한 리소스를 깔끔하게 정리해주지 않으면 다음 테스트에서 문제를 일으킬 수 있다.
- 빈은 싱글톤으로 상태를 가지지 않기 때문에 한 번만 만들고 여러 테스트가 공유해서 사용해도 된다.
- 하지만 JUnit은 매번 테스트마다 클래스 객체를 새로 만든다.
- JUnit은 테스트 클래스 전체에 걸쳐 한 번만 실행되는 `@BeforeClass` 스태틱 메서드를 통해 애플리케이션 컨텍스트를 만들어 저장해두고 테스트 메서드에서 사용할 수 있다.

### 2.4.1 테스트를 위한 애플리케이션 컨텍스트 관리

- 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다.
- 스프링 테스트 컨텍스트 프레임워크 적용(소스 참고)
    - `@RunWith`: JUnit 프레임워크의 테스트 실행 방법을 확장할 때 사용하는 어노테이션
        - `SpringJUnit4ClassRunner` 클래스가 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행한다.
    - `@ContextConfiguration`: 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정하는 어노테이션
- 테스트 메서드의 컨텍스트 공유
    - 다음 코드를 통해 애플리케이션 컨텍스트가 재사용되는지 확인할 수 있다.
    ```java
    @Before
    public void setUp() {
        System.out.println(this.context);  
        System.out.println(this);  
    }  
    ```
    - 테스트 수행 속도가 빨라진다.
        - 최초 애플리케이션 컨텍스트가 만들어지면서 가장 오랜 시간이 소모되고, 그 다음부터는 테스트 실행 시간이 매우 짧아진다.
- 테스트 클래스의 컨텍스트 공유
    - 여러 개의 테스트 클래스에서 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.
- `@Autowired`
    - 스프링의 DI에 사용되는 애노테이션
    - 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾아서 주입해준다.
        - 타입에 의한 자동 와이어링
    - 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록하기 때문에 `ApplicationContext` 타입의 빈을 DI가 가능하다.
    - 또한 `UserDao` 빈을 직접 DI 받을 수 있다.

### 2.4.2 DI 와 테스트

- 항상 `SimpleDriverDataSource`를 사용 할 예정이지만 `Datasource`인터페이스를 사용하고 DI를 통해 주입받는 방식을 사용해야 한다.
    - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
    - 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다.
    - 효율적인 테스트를 손쉽게 만들 수 있다.
        - DI는 테스트가 작은 단위의 대상에 대해 독립적으로 만들어지고 실행되게 하는데 중요한 역할을 한다.
- 테스트 코드에 의한 DI
    - 운영 환경과 테스트 환경을 분리할 수 있다.
        - 테스트 환경에서는 테스트 전용 `DataSource` 객체로 바꿔줄 수 있다.
    - 수동으로 DI하는 방법을 사용할 때는 `@DirtiesContext` 어노테이션을 추가한다.
        - 테스트에서 애플리케이션 컨텍스트의 구성이나 상태를 변경한다는 것을 테스트 컨텍스트 프레임워크에 알려준다.
        - 테스트 컨텍스트는 이 에노테이션이 붙은 테스트를 클래스에는 애플리케이션 컨텍스트 공유를 허용하지 않는다.
            - 테스트 메서드를 수행하고 나면 매번 새로 어플리케이션 컨텍스트를 생성 생성한다.
- 테스트를 위한 별도의 DI 설정(소스 참고)
    - 수동 ID 보다는 테스트를 위한 별도의 설정정보를 사용하는 것을 권장한다.
- 컨테이너 없는 DI 테스트
    - 테스트 코드에서 직접 객체를 만들고 DI 해서 사용할 수 있다.
    - 애플리케이션 컨텍스트가 만들어지는 시간을 절약할 수 있다.
    - 매번 새로운 객체가 만들어 진다.

> 침투적 기술과 비침투적 기술
>
> - 침투적(Invasive) 기술: 기술을 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나, 특정 인터페이스나 클래스를 사용하도록 강제하는 기술
> - 비침투적(Noninvasive) 기술: 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 적용 가능하기 때문에 순수한 코드를 유지할 수 있다.
> - 스프링은 비침투적인 기술의 대표적인 예다.

- DI를 이용한 테스트 방법 선택
    1. 스프링 컨테이너 없이 테스트
        - 테스트 수행 속도가 가장 빠르다.
        - 테스트 자체가 간결하다.
        - 객체 생성과 초기화가 단순하다면 이 방법을 가장 먼저 고려해야 한다.
    2. 스프링의 설정을 이용한 DI 방식의 테스트
        - 여러 객체와 복잡한 의존관계를 갖고 있는 경우 편리하다.
        - 환경에 따라 전용 설정파일을 만들어 사용을 권장한다.
    3. `@DirtiesContext` 어노테이션을 사용한 수동 DI 테스트
        - 예외적인 의존관계를 강제로 구성해야 하는 경우 사용할 수 있다.

## 2.5 학습 테스트로 배우는 스프링

- 일반적으로 애플리케이션 개발자는 자신이 만들고 있는 코드에 대한 테스트만 작성하면 된다.
- 프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해 작성한 테스트를 학습 테스트(Learning test)라고 한다.
    - 자신이 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익힐 수 있다.
    - 자신이 테스트를 만들려고 하는 기술이나 기능에 대해 얼마나 제대로 이해하고 있는지, 그 사용 방법을 바로 알고 있는지를 검증할 수 있다.

### 2.5.1 학습 테스트의 장점

- 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.
- 학습 테스트 코드를 개발 중에 참고할 수 있다.
- 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.
- 테스트 작성에 좋은 훈련이 된다.
- 새로운 기술을 공부하는 과정이 즐거워진다.

### 2.5.2 학습 테스트 예제

- JUnit 테스트 오브젝트 테스트(소스 참고)
- 스프링 테스트 컨텍스트 테스트(소스 참고)

### 2.5.3 버그 테스트

- 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트를 버그 테스트(Bug Test)라고 한다.
- 먼저 버그가 발생하는 조건의 테스트를 만들고, 애플리케이션 코드를 수정해서 테스트가 성공하면 버그가 해결된 것이다.
- 버그 테스트의 필요성과 장점
    - 테스트의 완성도를 높여준다.
        - 기존에 불충분했던 테스트를 보완해준다.
    - 버그의 내용을 명확하게 분석하게 해준다.
    - 기술적인 문제를 해결하는 데 도움이 된다.

> 동등분할(Equivalence Partitioning)
>
> - 같은 결과를 내는 값의 범위를 구분해서 각 대표 값으로 테스트하는 방법
> - 다양한 상황의 조합을 만들어 모든 경우에 대한 테스트를 해보는 것이 좋다.

> 경계값 분석(Boundary Value Analysis)
>
> - 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법
> - 보통 숫자의 입력 값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 등으로 테스트해보면 도움이 될 때가 많다.

## 2.6 정리

- 테스트는 자동화돼야 하고, 빠르게 실행할 수 있어야 한다.
- `main()` 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 순서에 따라서 결과가 달라지면 안 된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- `@Before`, `@After`를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- `@Autowired`를 사용하면 컨텍스트의 빈을 테스트 객체에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자.
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.
