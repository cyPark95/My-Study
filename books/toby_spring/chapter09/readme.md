# 9장 스프링 프로젝트 시작하기

- 유연하게 설계된 스프링을 잘 활용하기 위해 아키텍처의 종류와 프로젝트 구성 방식에 대해 알아본다.

## 9.1 자바 엔터프라이즈 플랫폼과 스프링 애플리케이션

- 스프링은 자바 언어를 사용하는 모든 종류의 프로젝트에 적용할 수 있지만, 주로 자바 엔터프라이즈 환경에서 실행되는 애플리케이션 개발을 목적으로 사용된다.

### 9.1.1 클라이언트와 백엔드 시스템

- 엔터프라이즈 애플리케이션은 클라이언트로서 다른 서비스를 요청할 수도 있고, 백엔드 시스템(EIS)과 연동하여 서비스 제공자의 역할을 수행할 수도 있다.
  <img alt="Image" src="https://github.com/user-attachments/assets/a73de69b-9cc8-48f4-a16c-e214260e74c7" />

### 9.1.2 애플리케이션 서버

- 스프링 애플리케이션을 자바 서버 환경에 배포하려면 JavaEE 기반 서버가 필요하다.
    - 경량급 WAS 또는 서블릿/JSP
        - 웹 모듈의 배포만 가능하다.
        - 스프링은 기본적으로 톰캣(Tomcat)이나 제티(Jetty) 같은 서블릿 컨테이너만으로도 대부분의 핵심기능을 이용할 수 있다.
    - 웹 애플리케이션 서버(WAS)
        - 다양한 형태의 모듈로 배포 가능하다.
        - 성능 면에서 크게 차이가 나지 않는다.
        - 안정성이나 관리 기능, 모니터링 기능이 뛰어나서 여러 대의 서버를 동시에 운영할 때 유리하다.
        - 자바 엔터프라이즈 버전(JavaEE) 표준을 최대한 활용할 수 있다.
- 스프링소스 tcServer
    - 자바 서버는 웹 모듈만 지원하는 서블릿 컨테이너인 아파치 톰캣을 가장 많이 사용한다.
    - 이를 기반으로 스프링 소스에서는 스프링 애플리케이션에 최적화된 tcServer를 개발했다.
        - 고급 서버 관리 기능, 배포 기능, 진단 기능 등 개발과 운영에서 필요한 중요한 기능들을 제공한다.

### 9.1.3 스프링 애플리케이션의 배포 단위

- 스프링의 배포 단위 세 가지
    - 독립 웹 모듈
        - 스프링은 일반적으로 war로 패키징된 독립 웹 모듈로 배포된다.
        - 서블릿 컨테이너를 사용한다면 독립 웹 모듈이 유일한 방법이다.
    - 엔터프라이즈 애플리케이션
        - 필요에 따라 확장자가 `ear`인 엔터프라이즈 애플리케이션으로 패키징해서 배포할 수 있다.
        - 하나 이상의 웹 모듈과 별도로 분리된 공유 가능한 스프링 컨텍스트를 엔터프라이즈 애플리케이션으로 묶어주는 방법이다.
    - 백그라운드 서비스 모듈
        - 스프링으로 만든 애플리케이션이 UI를 가질 필요는 없고, 서버 내에서 백그라운드 서비스처럼 동작할 필요가 있을 때 `rar` 패키지 방법을 사용할 수 있다.

## 9.2 개발도구와 환경

### 9.2.1 JavaSE와 JavaEE

- JavaSE/JDK
    - 스프링 3.0은 JavSE 5 버전에 추가된 기능과 JDK 6.0의 API를 사용하고 있기 때문에 최소 JDK 5.0 이상 버전이 필요하다.
- JavaEE/J2EE
    - 스프링 3.0은 JDK 6.0과 JavaEE 5.0을 기준으로 개발됐지만, 주요 기능은 JDK 5.0에서 동작하는 J2EE 1.4 버전과 호환된다.

### 9.2.2 IDE

- 통합개발환경(IDE)은 개발 과정에 필요한 작업을 한 곳에서 처리할 수 있도록 도와주는 통합 도구이다.
- 자바의 대표적인 IDE 들은 자바 엔터프라이즈 개발을 지원하고, 스프링 지원 기능도 제공한다.

### 9.2.3 SpringSource Tool Suite

- STS(SpringSource Tool Suite)은 이클립스를 기반으로 스프링 지원 플러그인과 관련 도구를 모아서 스프링 개발에 최적화 되도록 만들어진 IDE다.
- SpringIDE 플러그인
    - SpringIDE란, 스프링 개발에 유용한 기능을 제공하는 플러그인 모음으로 편리한 기능과 도구를 제공한다.
    - XML 에디터의 자동완성 기능을 제공한다.
        - 빈 클래스 이름 자동완성
            - 빈의 `class` 속성이나 프로퍼티를 입력 할 때, 클래스 이름에 대한 자동완성을 지원한다.
        - 빈 설정 오류 검증
            - 자바 코드를 작업할 때 실시간으로 컴파일 오류를 분석해서 표시해준다.
            - 이 기능을 잘 활용하면 빈 설정에 대한 오류를 애플리케이션 배포 없이 사전에 파악할 수 있습니다.
        - 프로젝트 생성, 설정파일 생성, 빈 등록 위저드
            - 스프링 프로젝트를 쉽게 생성할 수 있는 위저드를 제공한다.
            - XML 설정 파일의 스키마 선언을 간편하게 추가 또는 수정할 수 있다.
    - 빈 의존관계 그래프
        - XML 설정 파일을 분석해 빈 간의 참조 관계와 프로퍼티 구성을 한눈에 파악할 수 있게 표시해준다.
    - AOP 적용 대상 표시
        - XML 설정에서 AOP 포인트컷의 대상이 되는 빈을 확인할 수 있게 표시해준다.
        - 불필요한 빈이 AOP 대상이 되는 것을 방지하기 위해서 두 가지 방법이 있다.
            - 포인트컷 표현식에서 제외되도록 이름을 변경한다.
            - 포인트컷에 적용할 패키지를 지정하여 대상 범위를 제한한다.
    - 기타 지원 기능
        - 스프링 2.5부터는 애노테이션 기반의 빈 설정을 지원하지만, 서비스 빈 설정 등 상황에 따라 XML 설정과 함께 혼용하여 사용할 수 있다.
- STS 플러그인
    - SpringIDE에 더해, 스프링 애플리케이션의 서버 배치 등 다양한 추가 기능을 제공한다.
    - 대시보드 화면과 자주 발생하는 예외에 대한 지식 베이스(Knowledge Base) 검색 기능도 지원한다.
- 기타 플러그인
    - M2Eclipse
        - Maven 기반 의존성 관리를 지원하는 이클립스 플러그인으로, STS에 기본 포함되어 있다.
    - AJDT(AspectJ Development)
        - AspectJ AOP 개발을 지원하는 툴이다.
    - VMCI(Virtual Machine Core Integration)
        - VMWare 서버 또는 워크스테이션과 연동을 지원한다.
    - 이클립스 표준 플러그인
        - WTP(Web Tools Platform), EMP(Eclipse Modeling Project), Mylyn, DSDP(Device Software Development Platform) 등
          다양한 개발 환경을 지원한다.

### 9.2.4 라이브러리 관리와 빌드 툴

- 라이브러리 관리의 어려움
    - 많은 의존 라이브러리가 필요하지만, 모든 라이브러리를 항상 사용하는 것은 아니기 때문에 적절한 선택이 중요합니다.
    - 라이브러리는 다양한 버전이 존재하며, 버전이 맞지 않으면 컴파일 오류나 런타임 오류가 발생할 수 있다.
    - 복잡한 의존 관계 속에서는 동일한 라이브러리의 서로 다른 버전이 동시에 필요한 경우도 발생한다.
    - 자바는 모듈 개념이 존재하지 않아, 재패키징 기법을 사용해 이러한 충돌을 피할 수 있다.
        - 재패키징은 동일한 라이브러리의 서로 다른 버전을 각각 다른 패키지로 변경하여 충돌을 방지하는 방식이다.
- 라이브러리 선정
    - 스프링 프로젝트를 시작할 때는 먼저 필요한 기능을 정리하고, 이를 지원하는 기술과 라이브러리를 결정해야 한다.
    - 스프링 모듈
        - 스프링은 다양한 모듈로 구성되어 있기 때문에 프로젝트에 필요한 기능을 기준으로 모듈을 선택한다.
        - 모듈 간의 의존관계에 따라 필수 의존 모듈과 선택적 모듈을 구분해 선정해야 한다.
    - 라이브러리
        - 스프링 모듈은 서로다른 모듈 외에도 외부 라이브러리나 표준 API에 의존하는 경우도 있다.
        - 스프링 모듈과 의존하는 라이브러리의 종류와 특징에 맞는 라이브러리를 선택해야 한다.
    - 어떤 라이브러리를 사용할지 명확하지 않을 경우, 시행착오를 통해 적절한 조합을 찾아가는 방식도 필요할 수 있다.
    - 최소한의 모듈과 라이브러리로 시작해서, 개발 진행 중에 필요한 라이브러리만 점진적으로 추가하는 방식을 권장합니다.
    - 필요한 라이브러리가 없으면 컴파일 오류나 런타임 예외가 발생하지만, 불필요한 라이브러리는 즉각적인 문제를 일으키지는 않아도 다음과 같은 잠재적인 문제를 유발할 수 있다.
        - 모듈 파일의 크기를 증가신킨다.
        - 의존성 관리가 복잡해진다.
- 빌드 툴과 라이브러리 관리
    - IDE에서는 자동 빌드 기능과 관련 빌더를 추가하면 복잡한 빌드 작업도 간편하게 수행할 수 있다.
    - 하지만 IDE가 없는 환경에서도 일관된 빌드를 유지하기 위해, Maven 같은 독립적인 빌드 툴의 사용이 권장된다.
    - Maven은 POM을 기반으로 선언적인 방식으로 빌드와 프로젝트 관리를 수행한다.
        - POM에 필요한 의존 라이브러리만 선언해두면, Maven이 원격 저장소에서 자동으로 라이브러리를 다운로드하여 사용할 수 있도록 해준다.
        - 전이적(Transitive) 의존성 관리 기능을 통해, 지정한 라이브러리가 필요로 하는 다른 라이브러리들도 자동으로 함께 다운로드된다.
    - 스프링의 모든 모듈은 POM 정보를 갖고 있지만 대부분 선택 라이브러리기 때문에 명시적으로 POM에 선언해줘야 한다.
    - 스프링의 모든 모듈은 POM 정보를 갖고 있으나 대부분 선택적이므로, 실제 필요한 모듈은 명시적으로 POM에 선언해야 한다.
    - 라이브러리 선택에 대한 수고가 완전히 사라지는 것은 아니지만, 라이브러리 그룹을 구성하고 이를 POM에 반영해두면 효율적인 관리가 가능하다.
      <img alt="Image" src="https://github.com/user-attachments/assets/acecae65-fa39-4e91-a1e0-6f659cdc35bc" />
- 스프링 모듈의 두 가지 이름과 리포지토리
    - 스프링의 `core` 모듈 jar 파일을 보면 두 가지 이름 형식이 존재한다.
        - `spring-core-3.0.7.RELEASE.jar`
            - Maven 명명 규칙
            - 아티팩트 ID와 버전을 조합해 파일명으로 사용한다.
        - `org.springframework.core-3.0.7.RELEASE.jar`
            - OSGi 모듈 명명 규칙
            - 스프링의 모든 모듈은 OSGi 호환 모듈로, OSGi 플랫폼에서 사용하지 않더라도 OSGi 스타일의 이름 사용을 권장한다.
    - 두 파일은 내용이 동일하지만 배포 기술에 따라 관례적으로 이름만 다르게 사용하는 것이다.
    - OSGi 형식의 이름을 사용하는 스프링 모듈을 사용할 경우, Maven 대신 스프링소스의 엔터프라이즈 번들 리포지토리를 통해 의존성을 관리해야 한다.

## 9.3 애플리케이션 아키텍처

- 아키텍처는 다양한 방식으로 정의될 수 있지만, 가장 단순한 정의는 "하나의 시스템 내부 구성요소들이 어떤 책임을 가지며, 어떤 방식으로 관계를 맺고 동작하는지를 규정"한 것이다.
- 아키텍처는 단순한 정적인 구조를 넘어서, 그 구조 안에서 일어나는 동적인 행위와도 깊은 관련이 있다.

### 9.3.1 계층형 아키텍처

- 서로 다른 모듈 간의 결합도가 높을 때 발생할 수 있는 문제를 방지하기 위해 인터페이스 등을 활용해 유연한 경계를 만들고 모듈 간 의존성을 낮추는 구조적 분리가 필요하다.
- 아키텍처와 SoC
    - 성격이 다른 객체를 분리하던 과정을 아키텍처 레벨에서 좀 더 큰 단위에 적용할 수 있다.
    - 객체 간 책임을 분리하는 SoC 개념은, 아키텍처 수준에서도 더 큰 단위에 적용할 수 있다.
        - 데이터 접근 로직을 담당하는 계층
        - 비즈니스 로직을 구현한 POJO 계층
        - 웹 요청을 처리하는 계층
    - 이러한 방식으로 서로 다른 책임을 가진 그룹으로 나누는 것을 계층형 아키텍처(Layered Architecture)라고 한다.
    - 일반적으로 웹 기반 엔터프라이즈 애플리케이션은 세 개의 계층으로 구성되며, 이를 3계층(3-tier 또는 3-layer) 아키텍처라고 부른다.
- 3계층 아키텍처와 수직 계층
  <img alt="Image" src="https://github.com/user-attachments/assets/cc630f1f-d305-483a-aab0-62bf306049dd" />
    - 데이터 액세스(Data Access) 계층
        - 백엔드의 DB나 레거시 시스템과 연동하는 인터페이스 역할을 하는 계층이다.
        - 일반적으로 DAO 패턴을 사용하기 때문에 DAO 계층이라고도 부른다.
        - DB뿐 아니라 ERP, 레거시 시스템, 메인프레임 등 다양한 외부 시스템에 접근할 수 있어 EIS(Enterprise Information System) 계층이라고도 한다.
        - 외부 시스템을 호출해서 서비스를 이용하는 것은 기반(Infrastructure) 계층으로 따로 분류하기도 한다.
          <img width="500" height="300" alt="Image" src="https://github.com/user-attachments/assets/9b20b611-5cc0-4134-aab4-da19c8fb216f" />
        - 추상화 수준에 따라 세분화된 계층으로 구분될 수 있고, 수직적인 계층이라고도 한다.
        - 새로운 추상화된 계층이 추가되면 애플리케이션 코드에 큰 영향을 줄 수 있으며, 이를 최대한 유지할 수 있도록 하위 계층의 변화에 대응야 한다.
    - 서비스 계층
        - 비즈니스 로직을 담고 있는 계층이다.
        - 서비스 계층을 POJO로 구현하면 객체지향적인 설계 기법이 적용된 코드를 만들 수 있다.
        - 기술 API를 직접 다루지 않기 때문에 별도의 추상화 수직 계층이 필요하지 않다.
        - 엔터프라이즈 서비스를 제공하는 기반 서비스 계층과 구분되어야 한다.
        - 일반적으로 서비스 계층에서 기반 서비스 계층의 API를 호출하지만, 필요에 따라 기반 서비스 계층이 서비스 계층의 코드를 실행하기도 한다.
            - 대표적으로 스케줄링이 있다.
        - 원칙적으로 서비스 계층은 특정 기술이나 구현에 종속되지 않기 위해 기반 서비스 계층의 추상화된 인터페이스를 통해 접근해야 한다.
        - 서비스 계층은 데이터 액세스 계층과 프레젠테이션 계층이 변경돼도 그대로 유지될 수 있어야 한다.
    - 프레젠테이션 계층
        - 웹 기반의 UI를 만들고 그 흐름을 관리하는 계층이다.
        - 엔터프라이즈 애플리케이션의 프레젠테이션 계층은 보통 HTTP 프로토콜을 처리하는 서블릿 엔진을 기반으로 한다.
        - 다른 계층과 달리, 그 범위가 서버뿐만 아니라 클라이언트까지 확장될 수 있다.
        - 과거에는 입력 값 검증, 데이터 포맷 변환, 뷰(View) 렌더링까지 모두 서버에서 처리했으나, 최근에는 많은 로직이 클라이언트로 이동하고 있다.
- 계층형 아키텍처 설계의 원칙
    - 응집도는 높이면서 다른 계층과는 낮은 결합도를 유지해야 한다.
    - 각 계층은 자신의 역할에만 충실해야 하고, 자신과 관련 없는 기술 API 사용을 지양해야 한다.
        - 응집도가 높아지고 변화에 유연해지며 가독성이 향상된다.
    ```java
    public ResultSet findUsersByName(String name) throws SQLException;
    ```
    - 위 코드는 `ResultSet`, `SQLException`으로 인해 JDBC라는 특정 기술에 종속된다.
    - 기술 교체 시 다른 계층까지 함께 수정해야 하는 문제가 발생할 수 있다.
    - 다음과 같이 개선이 필요하다.
    ```java
    public List<User> findUsersByName(String name) throws DataAccessException;
    ```
    - 프레젠테이션 계층의 `HttpServletRequest`, `HttpSession` 같은 서블릿 객체를 서비스 계층으로 전달하면 안 된다.
        - 클라이언트 환경에 따라 비즈니스 로직 코드가 변경되어야 하는 상황이 발생할 수 있다.
        - POJO 기반의 빠르고 간단한 단위 테스트 작성이 어려워진다.
    - 어떤 경우에도 계층 사이의 낮은 결합도를 깨뜨리지 않도록 설계해야 한다.
        - 계층 사이의 호출은 인터페이스를 통해 이뤄져야 한다.
        - 인터페이스는 다른 계층에서 꼭 필요한 메서드만 노출해야 하며, 내부 구현 변경에도 쉽게 수정되지 않도록 주의해서 만들어야 한다.
    - 스프링의 DI는 객체 사이의 관계를 다루지만, 계층 구분을 보장하지 않기 때문에 주의해야 한다.

### 9.3.2 애플리케이션 정보 아키텍처

- 엔터프라이즈 시스템은 동시에 많은 작업이 빠르게 수행돼야 하는 시스템이다.
    - 요청을 처리하는 동안만 상태를 유지한다.
- 애플리케이션을 통해 흘러다니는 정보를 어떻게 다룰지를 결정하는 것도 아키텍처 설계에서 중요한 기준이 된다.
    - 데이터 중심 아키텍처
        - 정보를 단순히 값이나 데이터를 담는 객체 형태로 취급하는 구조다.
        - 비즈니스 로직이 DB 내부의 저장 프로시저나 SQL에 포함되는 경우가 많다.
    - 객체 중심 아키텍처
- DB/SQL 중심의 로직 구현 방식
    - 하나의 업무 트랜잭션에 모든 계층의 코드가 종속되는 경향이 있다.
    - 검색 조건은 SQL로 작성되며, 결과는 컬럼 이름으로 매핑되기 때문에 DB 테이블 컬럼명이 변경되면 뷰(View)까지 영향을 받는다.
    - 모든 계층의 코드는 하나의 업무에 종속되기 때문에 업무 변경 시 모든 계층의 코드가 함께 수정되어야 하며, 재사용이 어렵다.
    - 보통 업무 트랜잭션 단위로 코드를 묶기 때문에 기능이 세분화되거나 재사용되지 못하고, 대부분의 코드가 작업 단위와 1:1로 매핑된다.
      <img alt="Image" src="https://github.com/user-attachments/assets/99627b3c-9e10-4809-9d21-131c982d33cf" />
    - 이런 방식의 아키텍처는 상대적으로 개발하기 쉽지만, 자바 코드를 DB와 웹 화면을 연결하는 인터페이스 도구로 전락시킨다.
    - 결국 각 계층이 독립적인 것처럼 보이지만, SQL과 그 결과 데이터가 접착제 역할을 하여 강한 결합을 만든다.
        - 강한 결합으로 객체지향의 장점을 활용하기 어렵다.
        - 중복 코드가 쉽게 발생하고, 제거하기 어렵다.
        - 로직을 DB와 SQL에 많이 담을수록 확장성이 떨어진다.
    - 애플리케이션 서버와 그 안의 객체는 비용이 적게 들고, 확장이 용이하며 안정성과 검증 편의성도 뛰어나다.
    - 따라서 DB에는 부하가 적은 단순 작업만 맡기고, 복잡한 로직은 애플리케이션 계층의 객체에서 처리하도록 하는 것이 바람직하다.
    - DB 중심 아키텍처에서는 스프링의 장점을 제대로 활용하기 어렵다.
- 거대한 서비스 계층 방식
    - 주요 로직을 서비스 계층에서 처리하면 DB 중심 아키텍처의 단점을 피할 수 있다.
        - 객체지향 개발의 장점을 활용할 기회가 많아진다.
        - DAO와 SQL이 단순해지고, 서비스 계층 코드에서 재사용이 가능하다.
    - 그러나 비즈니스 로직이 복잡해질수록 거대한 서비스 계층(Fat Service Layer) 이 만들어진다.
      <img alt="Image" src="https://github.com/user-attachments/assets/14192909-e208-489e-add2-34ca7cf7b56a" />
    - 서비스 계층의 비즈니스 로직에 맞춰 SQL이 작성되기 때문에 여전히 데이터 액세스 계층과 강한 결합을 가진다.
    - 서비스 계층의 메서드는 트랜잭션 단위로 작성되므로, DAO를 공유할 수 있는 것 외에는 코드 중복이 발생할 가능성이 높다.

### 9.3.3 오브젝트 중심 아키텍처

- 객체 중심 아키텍처는 도메인 모델을 반영하는 객체를 만들고, 객체 구조 안에 정보를 담아서 각 계층 사이에 전달하게 만든다.
- 데이터와 객체
    - 데이터 중심 아키텍처에서는 DAO가 생성한 SQL 결과에 모든 계층의 코드가 의존하게 된다.
    - 하지만 객체 중심 아키텍처에서는 도메인 모델이 전 계층에서 동일한 의미를 갖기 때문에 일관된 구조로 활용할 수 있다.
    - 자바 언어의 특성을 활용해 데이터를 유연하게 가공할 수 있다.
        - 자바는 레퍼런스 변수를 통해 직접 객체를 연결할 수 있다.
        - 테이블과 달리 상호 참조가 가능하다.
    - 도메인 모델 기반의 객체 구조에 맞게 변환 과정이 필요하지만, 이후에는 계층 간 강한 결합을 제거할 수 있다.
        - DAO는 도메인 객체에 정보를 담기만 하면 되고, 그 활용 방식까지 신경 쓸 필요가 없다.
        - 서비스 계층은 DAO가 어떤 SQL을 사용했는지 알 필요 없이, 전달받은 객체를 활용해 비즈니스 로직을 처리하면 된다.
        - 프레젠테이션 계층은 비즈니스 로직의 내부 동작을 알 필요 없이, 결과 객체만 활용하면 된다.
- 도메인 객체를 사용하는 코드
    - `Category`와 `Product`가 1:N 관계일 때 카테고리에 포함된 상품 가격의 총합을 계산한다면, 객체 중심 방식을 사용하면 단순하고 명확하게 구현할 수 있다.
        ```java
        public class CategoryService {
            
            // ...

            public int calcTotalOfProductPrice(Category category) {
                int sum = 0;
                for (Product product : category.getProduct()) {
                    sum += product.getPrice();
                }
      
                return sum;
            }
        }
        ```
        - 단위 테스트를 통해 쉽게 검증할 수 있다.
        - 로직이 변경되더라도 코드 수정이 간단하다.
        - `Category`는 독립된 객체이므로 트랜잭션과 관계없이 서비스 계층 어디서든 이 메서드를 활용할 수 있다.
    - 반대로, 데이터 중심 방식이라면 SQL로 데이터를 가져오는 방법에 따라 다른 코드가 작성되며, 그 결과 중복 코드가 발생한다.
- 도메인 객체 사용의 문제점
    - 최적화된 SQL을 매번 직접 작성하는 방식에 비해 성능 손해를 감수해야 한다.
        - DAO는 객체가 어떻게 사용될지 알 수 없기 때문에 대부분 도메인 객체의 모든 필드를 조회 후 전달한다.
    - 사용하지 않는 참조 레퍼런스를 `null`로 남겨둔 경우, `NullPointerException`이 발생할 수 있다.
        - 이를 피하기 위해 최적화된 DAO를 작성하면 계층 간 결합도가 높아질 수 있다.
    - 지연 로딩(Lazy Loading) 기법을 활용하면 최소한의 객체 정보만 읽어두고, 필요할 때 DB에서 동적으로 조회할 수 있다.
        - 하지만 상황에 맞는 DAO 메서드가 추가돼야 하며, 서비스 계층이 어떤 DAO를 쓸지 알아야 하기 때문에 약하지만 계층 간 결합이 발생한다.
    - 객체/RDB 매핑(Object RDB Mapping: ORM) 기술을 사용하는 것이 가장 이상적이다.
        - 기본적으로 지연 로딩 기법 등을 제공한다.
        - SQL 결과를 도메인 객체에 매핑하는 등 복잡한 DAO 코드를 작성할 필요가 없다.
        - 내부적으로 최적화된 SQL을 생성하도록 세밀한 튜닝이 가능하다.
        - 자주 변경되지 않고 여러 로직에서 사용하는 레퍼런스는 ORM의 객체 캐시에 보관하여 성능을 높일 수 있다.
    - 도메인 객체는 자바 객체이므로, 구조 정보 뿐만 아니라 속성(Attribute)과 행위(Operation)를 결합한 객체지향적 장점을 적극적으로 활용해야 한다.
- 빈약한 도메인 객체 방식
    - 도메인 정보만 담고, 해당 정보를 활용하는 기능은 가지지 않은 객체를 빈약한(Anemic) 객체라고 한다.
    - 이 방식에서는 비즈니스 로직이 서비스 계층에 존재하므로, 구조적으로는 데이터 중심 아키텍처의 거대한 서비스 계층과 유사하다.
      <img alt="Image" src="https://github.com/user-attachments/assets/c0a3cf5d-f1b0-4b7b-9b54-72e3e0ad2310" />
    - 하지만 비즈니스 로직이 복잡하지 않다면, 가장 구현하기 쉽고 3계층 구조의 특징을 살려 개발할 수 있는 아키텍처이다.
- 풍성한 도메인 객체 방식
    - 풍성한 도메인 객체(Rich Domain Object)은 영리한 도메인 객체(Smart Domain Object) 방식이라고도 불린다.
    - 이 방식은 빈약한 도메인 객체의 단점을 극복하고, 객체지향의 장점을 잘 활용할 수 있도록 개선된 방식이다.
    - 서비스 계층에 작성했던 `calcTotalOfProductPrice()` 메서드를 `Category` 클래스 내부로 옮기면 데이터와 관련 기능이 한곳에 모이게 되어 응집도가 높아진다.
        ```java
        public class InventoryService {
            
            private final CategoryService categoryService;
      
            public void setCategoryService(CategoryService categoryService) {
                this.categoryService = categoryService;
            }
            public void complexInventoryAnalysis() {
                // ...
                int total = this.categoryService.calcTotalOfProductPrice(category);
                // ...
            }
        }
        ```
        - 기존 방식은 서비스 클래스를 DI한 뒤, 해당 메서드를 호출해야 하는 번거로움이 있었다.
        ```java
        public class InventoryService {

            public void complexInventoryAnalysis() {
                // ...
                int total = category.calcTotalOfProductPrice();
                // ...
            }
        }
        ```
        - 도메인 객체 안에 메서드를 두면 훨씬 간결하고 직관적이며, 이해하기 쉽고 객체지향적이다.
    - 단, 도메인 객체는 스프링 빈이 아니므로 다른 스프링 빈을 DI 받을 수 없으며, 따라서 여전히 서비스 계층이 필요하다.
      <img alt="Image" src="https://github.com/user-attachments/assets/a619a779-f9bd-455e-a374-e3ca25ad6311" />
    - 풍성한 도메인 객체 방식은 빈약한 도메인 객체 방식에 비해 서비스 계층 코드가 간결해진다.
- 도메인 계층 방식
    - 도메인 계층 방식은 도메인 객체가 기존 3계층의 객체를 DI 받아 직접 활용할 수 있도록 기존 3계층과 같은 레벨로 격상되어 독립적인 하나의 계층을 이루는 방식이다.
    - 도메인 객체가 독립된 계층을 형성하면 두 가지 특징을 갖는다.
        - 도메인에 종속적인 비즈니스 로직은 서비스 계층이 아닌 도메인 계층의 객체 안에서 처리된다.
        - 도메인 객체가 데이터 액세스 계층이나 기반 계층의 기능을 직접 활용할 수 있다.
            - AspectJ AOP를 사용하면 도메인 객체 생성 시 스프링 빈 DI를 적용할 수 있다.
    - 서비스 계층의 역할
        - 여러 도메인 객체의 기능을 조합하여 복잡한 작업을 수행할 때 협력자로 동작한다.
        - 도메인 계층을 거치지 않고 데이터 액세스 계층에서 가져온 정보를 클라이언트에 직접 제공해야 할 경우 인터페이스 역할을 한다.
        - 트랜잭션 경계를 설정하거나 기반 서비스를 이용하는 경우 필요하다.
    - 도메인 객체의 활용 범위에 대한 고려사항
        - 모든 계층에서 도메인 객체 사용
            - 단순하고 편리하며 객체 중심 아키텍처의 장점을 충분히 누릴 수 있다.
            - 그러나 프레젠테이션 계층이나 뷰에서 비즈니스 로직, 작업 결과 반영 등을 직접 수행하면 심각한 문제가 발생할 수 있다.
            - 이를 방지하기 위해 코딩 정책이나 AspectJ의 정책/표준 강제화(Policy/Standards Enforcement) 기능을 통해 가이드라인을 적용할 수 있다.
        - 도메인 계층에서만 도메인 객체 사용
            - 도메인 계층 밖으로 전달할 때는 DTO(Data Transfer Object)를 사용한다.
                - DTO는 읽기 전용 객체로 설계되어 상태 변화를 허용하지 않는다.
                - 단, 매번 변환 과정이 필요하다는 번거로움이 있다.
      <img alt="Image" src="https://github.com/user-attachments/assets/16785b47-daac-4ae6-9df6-0f3733fe20c6" />
    - 도메인 계층은 기존 3계층과 유사한 수준에서 독립적인 역할을 담당하지만, 사용자별 요청마다 독립적인 상태를 유지해야 하므로 생명주기가 짧고 싱글톤으로 공유될 수 없다.
    - 응집도가 높기 때문에 이러한 단점을 감수하더라도 복잡하고 변경이 잦은 도메인의 경우 적합하다.
        - 단위 테스트 작성이 용이하다.
        - 객체지향적 설계의 장점을 활용하여 복잡성을 유연하게 대응할 수 있다.
- DTO와 리포트 쿼리
    - 리포트 쿼리(Report Query)란 종합 분석 리포트처럼 여러 테이블에 걸쳐 존재하는 데이터를 분석하거나 통계 결과를 생성하는 쿼리를 말한다.
    - 리포트 쿼리와 같이 적절한 도메인 객체로 매핑하기 어려운 상황에서는 DTO를 사용해 결과를 전달할 수 있다.
    - 또한 시스템 간 통신 시 전송 규약에 맞추어 도메인 객체의 정보를 가공해야 할 경우에도 DTO를 활용할 수 있다.

### 9.3.4 스프링 애플리케이션을 위한 아키텍처 설계

- 계층형 아키텍처
    - 스프링을 사용하는 엔터프라이즈 애플리케이션에서는 3계층 구조를 가장 많이 사용하며, 스프링 또한 3계층 구조에 적합하도록 설계되어 있다.
    - 3계층 구조는 반드시 객체 단위로 명확히 분리되는 것은 아니다.
        - 여러 계층이 통합되어 하나의 객체에 포함될 수도 있다.
            - 비즈니스 로직이 단순한 경우 서비스 계층을 데이터 액세스 계층이나 프레젠테이션 계층에 통합할 수 있다.
            - 하지만 프레젠테이션 계층에 서비스 계층을 통합하는 경우 트랜잭션 경계의 크기가 크고, 트랜잭션 전파 설정도 애매해지므로 스프링에서는 권장하지 않는다.
        - 하나의 계층이 세분화 될 수도 있다.
            - 프레젠테이션 계층은 보통 MVC 패턴을 따르며, 스프링은 특히 컨트롤러 역할을 세분화하여 여러 단계의 객체로 나눌 수 있도록 설계되었다.
    - 프레젠테이션 계층의 결계는 클라이언트까지 확장되기도 한다.
        - SOFEA(Service Oriented Front End Architecture) 아키텍처는 클라이언트로 다운로드돼서 클라이언트 장치 내에서 프레젠테이션 기능을 수행하는 구조를 갖는다.
    - 스프링을 처음 도입할 때는 3계층 구조에 익숙해지는 것을 권장한다.
      - 프레젠테이션 계층은 SpringMVC를 이용한다. 
      - 서비스 계층은 POJO로 구현하고,  트랜잭션 AOP를 사용한다. 
      - 데이터 액세스 계층은 JDBC를 비롯해서 ORM(Hibernate, JPA 등)을 활용하는 것이 좋다.
- 정보 전송 아키텍처
