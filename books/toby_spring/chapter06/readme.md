# 6장 AOP

- AOP(Aspect-Oriented Programming)는 IoC/DI, 서비스 추상화와 함께 스프링의 3대 핵심 기반 기술 중 하나
- AOP는 용어와 개념이 다소 어려워 충분한 이해가 뒷받침될 때 효과적으로 활용할 수 있다.
- 스프링에서 대표적으로 AOP가 적용된 사례는 선언적 트랜잭션 관리이다.

## 6.1 트랜잭션 코드의 분리

- `UserService`는 트랜잭션 기술에 독립적이고, 메일 발송 기술과 환경에 종속되지 않도록 다듬어 왔다.
- 하지만 트랜잭션 경계 설정을 위한 코드가 존재한다.

### 6.1.1 메서드 분리

- 비즈니스 로직과 트랜잭션을 담당하는 두 가지 종류의 코드가 구분되어 있다.
- 두 코드 간에 주고받는 정보가 없다.
- 메서드 추출을 통해 독립시킬 수 있다.(소스 참고)

### 6.1.2 DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService`에 존재한다.
- DI 적용을 이용한 트랜잭션 분리
    - 현재 `UserService` 클래스와 클라이언트 간의 관계가 강한 결합도로 고정되어 있다.
        - 트랜잭션 코드를 `UserService` 밖으로 빼버리면 클라이언트는 트랜잭션 기능이 빠진 `UserService`를 사용하게 된다.
    - 인터페이스와 DI를 적용하면 클라이언트와 결합이 약해지고, 유연한 확장이 가능해진다.
- `UserService` 인터페이스 도입(소스 참고)
- 분리된 트랜잭션 기능(소스 참고)
- 트랜잭션 적용을 위한 DI 설정(소스 참고)
- 트랜잭션 분리에 따른 테스트 수정(소스 참고)
    - `@Autowired`는 기본적으로 타입이 일치하는 빈을 찾아준다.
- 트랜잭션 경계설정 코드 분리의 장점
    - 비즈니스 로직을 담당하고 있는 `UserServiceImpl`는 트랜잭션과 같은 기술적인 내용은 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 작은 단위로 쪼개서 테스트하는 것이다.
    - 테스트가 실패했을 때 원인을 찾기 쉽다.
    - 테스트의 의도나 내용이 분명해진다.
    - 테스트를 작성하기 쉽다.

### 6.2.1 복잡한 의존관계 속의 테스트

- 현재 `UserService`는 세 가지 의존 객체가 필요하다.
    - `UserDao`
    - `MailSender`
    - `PlatformTransactionManager`
- 세 가지 의존 객체들은 테스트가 진행되는 동안 JDBC, 네트워크, 메일 서버 등 함께 테스트 된다.
    - 테스트를 준비하기 힘들다.
    - 환경이 달라지면 동일한 테스트 결과를 받지 못할 수 있다.
    - 테스트 수행 속도가 느리다.

### 6.2.2 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향 받지 않도록 고립시킬 필요가 있다.
- 테스트를 위한 `UserServiceImpl` 고립
    - `UserDao`는 테스트 결과를 검증하기 위한 목 객체로 작성한다.
- 고립된 단위 테스트 활용
    - `UserDao`를 통해 테스트에 필요한 정보를 DB에 넣기위해 준비한다.
    - `MailSender` 목 객체 DI를 통해 의존 객체와 서버 등에서 고립시킨다.
- `UserDao` 목 객체(소스 참고)
    - 사용하지 않는 메서드는 실수로 사용되지 않도록 `UnsupportedOperationException` 예외가 발생하도록 만드는 것을 권장한다.
- 테스트 수행 성능의 향상
    - 의존 대상으로부터 고립된 테스트를 통해 수행 속도가 빨라졌다.

### 6.2.3 단위 테스트와 통합 테스트

- 단위 테스트의 단위는 정하기 나름이지만, 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다.
- 단위 테스트
    - 테스트 대역을 통해 의존 객체나 외부 리소스를 사용하지 않는 고립된 테스트
- 통합 테스트
    - 두 개 이상의 성격이나 계층이 다른 객체가 연동하고록 만들거나 외부 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트를 결정하는 가이드라인
    - 항상 단위 테스트를 먼저 고려한다.
    - 단위 테스트는 외부 의존성을 차단하고, 빠르고 효과적으로 작성할 수 있다.
    - 외부 리소스가 필요한 테스트는 통합 테스트로 작성한다.
    - DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하는 DAO는 고립된 테스트 작성이 어렵고, 가치가 없기 때문에 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
    - DAO와 같이 DB 연동이 필수인 코드는 통합 테스트로 분류한다.
    - DAO를 충분히 검증해두면, DAO를 이용하는 코드는 스텁이나 목 객체로 대체해 테스트할 수 있다.
    - 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
    - 충분한 단위 테스트를 거친다면 통합 테스트의 부담은 상대적으로 줄어든다.
    - 단위 테스트가 너무 복잡하면 처음부터 통합 테스트를 고려해야 하지만, 가능한 많은 부분을 미리 단위 테스트로 검증하는 것이 유리하다.
    - 스프링 테스트 컨텍스트 프레임워크를 사용하는 테스트는 통합 테스트에 해당한다.
    - 가능하다면 스프링 없이 코드 레벨에서 단위 테스트를 작성하고, 스프링 설정이나 추상적 레벨의 테스트가 필요할 경우 스프링 테스트 컨텍스트 프레임워크를 이용한 통합 테스트를 작성한다.
- 스프링이 권장하는 유연한 코드를 만들다보면 테스트도 만들기 쉬워지고, 테스트는 리팩토링과 개선을 통해 코드의 품질을 높여준다.

### 6.2.4 목 프레임워크

- 단위 테스트에서 목 객체를 만드는일은 번거롭다.
- 목 객체를 편리하게 작성하도록 도와주는 다양한 목 객체 지원 프레임워크가 있다.
- Mockito 프레임워크
    - 목 클래스를 일일히 준비해둘 필요가 없다는 특징을 가지고 있다.
    - `org.mockito.Matchers` 클래스에 정의된 스태틱 메소드를 제공한다.
    - Mockito를 이용한 테스트 코드(소스 참고)

## 6.3 다이나믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

- 트랜잭션 경계설정 코드 분리
    - 트랜잭션을 적용하는 부가기능을 핵심기능이 담긴 클래스에서 독립 시켰다.
    - 부가기능 코드에서는 핵심기능으로 요청을 위힘해주는 과정에서 부가적인 기능을 적용해줄 수 있다.
    - 클라이언트는 인터페이스로 접근하기 때문에 핵심기능을 가진 클래스를 기대하고 사용한다.
    - 프록시(Proxy): 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자, 대리인과 같은 역할
    - 타깃(Target) 또는 실체(Real Subject): 프록시를 통해 요청을 위임받아 처리하는 실제 객체
    - 프록시의 목적
        - 클라이언트가 타깃에 접근하는 방법을 제어한다.
        - 타깃에 부가적인 기능을 부여해 준다.
- 데코레이터 패턴
    - 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
        - 다이나믹하게 기능을 부가한다는 의미는 컴파일 시점에는 어떤 방법과 순서로 프록시와 타깃이 정해져 있지 않는 것을 뜻한다.
    - 데코레이터 패턴에서는 여러 개의 프록시를 사용할 수 있다.
    - 프록시로 동작하는 각 데코테이터는 위임하는 대상에 인터페이스로 접근한다.
        - 위임 대상이 최종 타깃인지 다음 데코레이터 프록시인지 알 수 없다.
        - `UserServiceTx`는 데코레이터, `UserServiceImple`은 타깃이 된다.
    - 데코레이터 패턴은 타깃의 코드와 클라이언트사 호출 방법을 변경하지 않고 새로운 기능을 추가할 때 유용한 방법이다.
- 프록시 패턴
    - 일반적으로 프록시는 클라이언트와 사용 대상 사이에 대리 역할을 맡는 객체를 두는 방법을 총칭한다.
    - 프록시 패턴은 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가르킨다.
    - 프록시 패턴은 타깃의 기능 자체에는 관여하지 않고 접근하는 방법을 제어해주는 프록시를 이용하는 방법이다.

### 6.3.2 다이나믹 프록시

- 프록시 패턴을 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.
- 하지만 매번 새로운 클래스를 정의해야하고, 인터페이스의 모든 메서드를 구현해야하는 번거로움이 있다.
- 프록시의 구성과 프록시 작성의 문제점
    - 프록시의 기능
        - 타깃과 같은 메서드를 구현하고 있다가 메서드가 호출되면 타깃 객체로 위임한다.
        - 지정된 요청에 대해서는 부가기능을 수행한다.
    - 프록시를 만들기 번거로운 이유
        - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.
            - 부가기능이 필요 없는 메서드도 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
        - 부가기능 코드가 중복될 가능성이 있다.
- 리플렉션
    - 다이나믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    - 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 기능이다.
    - 리플렉션 학습 테스트(소스 참고)
- 프록시 클래스(소스 참고)
- 다이나믹 프록시 적용(소스 참고)
    - 프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 객체
    - 다이나믹 프록시는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 `InvocationHandler` 구현 객체의 `invoke()` 메서드로 넘긴다.
        - 타깃 인터페이스의 모든 메서드 요청이 하나의 메서드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.
    - 메서드와 파라미터 정보를 모두 알고 있기 때문에 리플렉션으로 타깃 객체의 메서드를 호출할 수 있다.
    - `Proxy.newProxyInstance()` 정적 팩토리 메서드를 통해 다이나믹 프록시를 생성할 수 있다.
- 다이나믹 프록시의 확장(소스 참고)
    - `Hello` 인터페이스의 메서드가 30개로 늘어난다면, 직접 구현한 프록시는 매번 코드를 추가해야 한다.
    - 다이나믹 프록시는 추가된 메서드가 자동으로 포함될 것이고, 부가기능은 `invoke()` 메서드에서 처리된다.

### 6.3.3 다이나믹 프록시를 이용한 트랜잭션 부가기능

- 다음 단점을 해결하기 위해 `UserServiceTx`를 다이나믹 프록시 방식으로 변경한다.
    - 인터페이스의 모든 메서드를 구현해야 한다.
    - 트랜잭션이 필요한 메서드마다 트랜잭션 처리 코드가 중복돼서 나타난다.
- 트랜잭션 `InvocationHandler`(소스 참고)
- `TransactionHandler`와 다이나믹 프록시를 이용하는 테스트
    ```java
    @Test
    void upgradeAllOrNothing() throws Exception {
        // ...

        TransactionHandler txHandler = new TransactionHandler();
        txHandler.setTarget(testUserService);
        txHandler.setTransactionManager(transactionManager);
        txHandler.setPattern("upgradeLevels");
        UserService txUserService = (UserService) Proxy.newProxyInstance(
                getClass().getClassLoader(),
                new Class[]{UserService.class},
                txHandler
        );

        // ...
    }
    ```

### 6.3.4 다이나믹 프록시를 위한 팩토리 빈

- DI의 대상이 되는 다이나믹 프록시 객체를 스프링 빈으로 등록할 방법이 없다.
- 스프링은 지정된 클래스의 이름을 가지고 리플렉션을 이용해 해당 클래스의 객체를 만든다.
    - `Class.newInstance()` 메서드는 해당 클래스의 파라미터가 없는 생성자를 호출한다.
- 팩토리 빈
    - 스프링은 클래스 정보를 가지고 빈을 만들 수 있는 여러 가지 방법을 제공한다.
    - 팩토리 빈을 이용한 방법이 대표적이다.
        - 팩토리 빈은 스프링을 대신해서 객체의 생성 로직을 담당하도록 만들어진 특별한 빈이다.
        - 팩토리 빈을 만드는 간단한 방법은 스프링의 `FactoryBean` 인터페이스를 구현하는 것이다.
- 팩토리 빈의 설정(소스 참고)
- 다이나믹 프록시를 만들어주는 팩토리 빈
    - 팩토리 빈의 `getObject()` 메서드에 다이나믹 프록시 객체를 만들어주는 코드를 넣으면 스프링 빈으로 만들 수 있다.
- 트랜잭션 프록시 팩토리 빈(소스 참고)
- 트랜잭션 프록시 팩토리 빈 테스트(소스 참고)
