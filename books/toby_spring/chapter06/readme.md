# 6장 AOP

- AOP(Aspect-Oriented Programming)는 IoC/DI, 서비스 추상화와 함께 스프링의 3대 핵심 기반 기술 중 하나
- AOP는 용어와 개념이 다소 어려워 충분한 이해가 뒷받침될 때 효과적으로 활용할 수 있다.
- 스프링에서 대표적으로 AOP가 적용된 사례는 선언적 트랜잭션 관리이다.

## 6.1 트랜잭션 코드의 분리

- `UserService`는 트랜잭션 기술에 독립적이고, 메일 발송 기술과 환경에 종속되지 않도록 다듬어 왔다.
- 하지만 트랜잭션 경계 설정을 위한 코드가 존재한다.

### 6.1.1 메서드 분리

- 비즈니스 로직과 트랜잭션을 담당하는 두 가지 종류의 코드가 구분되어 있다.
- 두 코드 간에 주고받는 정보가 없다.
- 메서드 추출을 통해 독립시킬 수 있다.(소스 참고)

### 6.1.2 DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService`에 존재한다.
- DI 적용을 이용한 트랜잭션 분리
    - 현재 `UserService` 클래스와 클라이언트 간의 관계가 강한 결합도로 고정되어 있다.
        - 트랜잭션 코드를 `UserService` 밖으로 빼버리면 클라이언트는 트랜잭션 기능이 빠진 `UserService`를 사용하게 된다.
    - 인터페이스와 DI를 적용하면 클라이언트와 결합이 약해지고, 유연한 확장이 가능해진다.
- `UserService` 인터페이스 도입(소스 참고)
- 분리된 트랜잭션 기능(소스 참고)
- 트랜잭션 적용을 위한 DI 설정(소스 참고)
- 트랜잭션 분리에 따른 테스트 수정(소스 참고)
    - `@Autowired`는 기본적으로 타입이 일치하는 빈을 찾아준다.
- 트랜잭션 경계설정 코드 분리의 장점
    - 비즈니스 로직을 담당하고 있는 `UserServiceImpl`는 트랜잭션과 같은 기술적인 내용은 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 작은 단위로 쪼개서 테스트하는 것이다.
    - 테스트가 실패했을 때 원인을 찾기 쉽다.
    - 테스트의 의도나 내용이 분명해진다.
    - 테스트를 작성하기 쉽다.

### 6.2.1 복잡한 의존관계 속의 테스트

- 현재 `UserService`는 세 가지 의존 객체가 필요하다.
    - `UserDao`
    - `MailSender`
    - `PlatformTransactionManager`
- 세 가지 의존 객체들은 테스트가 진행되는 동안 JDBC, 네트워크, 메일 서버 등 함께 테스트 된다.
    - 테스트를 준비하기 힘들다.
    - 환경이 달라지면 동일한 테스트 결과를 받지 못할 수 있다.
    - 테스트 수행 속도가 느리다.

### 6.2.2 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향 받지 않도록 고립시킬 필요가 있다.
- 테스트를 위한 `UserServiceImpl` 고립
    - `UserDao`는 테스트 결과를 검증하기 위한 목 객체로 작성한다.
- 고립된 단위 테스트 활용
    - `UserDao`를 통해 테스트에 필요한 정보를 DB에 넣기위해 준비한다.
    - `MailSender` 목 객체 DI를 통해 의존 객체와 서버 등에서 고립시킨다.
- `UserDao` 목 객체(소스 참고)
    - 사용하지 않는 메서드는 실수로 사용되지 않도록 `UnsupportedOperationException` 예외가 발생하도록 만드는 것을 권장한다.
- 테스트 수행 성능의 향상
    - 의존 대상으로부터 고립된 테스트를 통해 수행 속도가 빨라졌다.

### 6.2.3 단위 테스트와 통합 테스트

- 단위 테스트의 단위는 정하기 나름이지만, 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다.
- 단위 테스트
    - 테스트 대역을 통해 의존 객체나 외부 리소스를 사용하지 않는 고립된 테스트
- 통합 테스트
    - 두 개 이상의 성격이나 계층이 다른 객체가 연동하고록 만들거나 외부 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트를 결정하는 가이드라인
    - 항상 단위 테스트를 먼저 고려한다.
    - 단위 테스트는 외부 의존성을 차단하고, 빠르고 효과적으로 작성할 수 있다.
    - 외부 리소스가 필요한 테스트는 통합 테스트로 작성한다.
    - DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하는 DAO는 고립된 테스트 작성이 어렵고, 가치가 없기 때문에 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
    - DAO와 같이 DB 연동이 필수인 코드는 통합 테스트로 분류한다.
    - DAO를 충분히 검증해두면, DAO를 이용하는 코드는 스텁이나 목 객체로 대체해 테스트할 수 있다.
    - 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
    - 충분한 단위 테스트를 거친다면 통합 테스트의 부담은 상대적으로 줄어든다.
    - 단위 테스트가 너무 복잡하면 처음부터 통합 테스트를 고려해야 하지만, 가능한 많은 부분을 미리 단위 테스트로 검증하는 것이 유리하다.
    - 스프링 테스트 컨텍스트 프레임워크를 사용하는 테스트는 통합 테스트에 해당한다.
    - 가능하다면 스프링 없이 코드 레벨에서 단위 테스트를 작성하고, 스프링 설정이나 추상적 레벨의 테스트가 필요할 경우 스프링 테스트 컨텍스트 프레임워크를 이용한 통합 테스트를 작성한다.
- 스프링이 권장하는 유연한 코드를 만들다보면 테스트도 만들기 쉬워지고, 테스트는 리팩토링과 개선을 통해 코드의 품질을 높여준다.

### 6.2.4 목 프레임워크

- 단위 테스트에서 목 객체를 만드는일은 번거롭다.
- 목 객체를 편리하게 작성하도록 도와주는 다양한 목 객체 지원 프레임워크가 있다.
- Mockito 프레임워크
    - 목 클래스를 일일히 준비해둘 필요가 없다는 특징을 가지고 있다.
    - `org.mockito.Matchers` 클래스에 정의된 스태틱 메소드를 제공한다.
    - Mockito를 이용한 테스트 코드(소스 참고)

## 6.3 다이나믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

- 트랜잭션 경계설정 코드 분리
    - 트랜잭션을 적용하는 부가기능을 핵심기능이 담긴 클래스에서 독립 시켰다.
    - 부가기능 코드에서는 핵심기능으로 요청을 위힘해주는 과정에서 부가적인 기능을 적용해줄 수 있다.
    - 클라이언트는 인터페이스로 접근하기 때문에 핵심기능을 가진 클래스를 기대하고 사용한다.
    - 프록시(Proxy): 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자, 대리인과 같은 역할
    - 타깃(Target) 또는 실체(Real Subject): 프록시를 통해 요청을 위임받아 처리하는 실제 객체
    - 프록시의 목적
        - 클라이언트가 타깃에 접근하는 방법을 제어한다.
        - 타깃에 부가적인 기능을 부여해 준다.
- 데코레이터 패턴
    - 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
        - 다이나믹하게 기능을 부가한다는 의미는 컴파일 시점에는 어떤 방법과 순서로 프록시와 타깃이 정해져 있지 않는 것을 뜻한다.
    - 데코레이터 패턴에서는 여러 개의 프록시를 사용할 수 있다.
    - 프록시로 동작하는 각 데코테이터는 위임하는 대상에 인터페이스로 접근한다.
        - 위임 대상이 최종 타깃인지 다음 데코레이터 프록시인지 알 수 없다.
        - `UserServiceTx`는 데코레이터, `UserServiceImple`은 타깃이 된다.
    - 데코레이터 패턴은 타깃의 코드와 클라이언트사 호출 방법을 변경하지 않고 새로운 기능을 추가할 때 유용한 방법이다.
- 프록시 패턴
    - 일반적으로 프록시는 클라이언트와 사용 대상 사이에 대리 역할을 맡는 객체를 두는 방법을 총칭한다.
    - 프록시 패턴은 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가르킨다.
    - 프록시 패턴은 타깃의 기능 자체에는 관여하지 않고 접근하는 방법을 제어해주는 프록시를 이용하는 방법이다.

### 6.3.2 다이나믹 프록시

- 프록시 패턴을 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.
- 하지만 매번 새로운 클래스를 정의해야하고, 인터페이스의 모든 메서드를 구현해야하는 번거로움이 있다.
- 프록시의 구성과 프록시 작성의 문제점
    - 프록시의 기능
        - 타깃과 같은 메서드를 구현하고 있다가 메서드가 호출되면 타깃 객체로 위임한다.
        - 지정된 요청에 대해서는 부가기능을 수행한다.
    - 프록시 작성의 문제점
        - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.
            - 부가기능이 필요 없는 메서드도 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
        - 부가기능 코드가 중복될 가능성이 있다.
- 리플렉션
    - 다이나믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    - 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 기능이다.
    - 리플렉션 학습 테스트(소스 참고)
- 프록시 클래스(소스 참고)
- 다이나믹 프록시 적용(소스 참고)
    - 프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 객체
    - 다이나믹 프록시는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 `InvocationHandler` 구현 객체의 `invoke()` 메서드로 넘긴다.
        - 타깃 인터페이스의 모든 메서드 요청이 하나의 메서드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.
    - 메서드와 파라미터 정보를 모두 알고 있기 때문에 리플렉션으로 타깃 객체의 메서드를 호출할 수 있다.
    - `Proxy.newProxyInstance()` 정적 팩토리 메서드를 통해 다이나믹 프록시를 생성할 수 있다.
- 다이나믹 프록시의 확장(소스 참고)
    - `Hello` 인터페이스의 메서드가 30개로 늘어난다면, 직접 구현한 프록시는 매번 코드를 추가해야 한다.
    - 다이나믹 프록시는 추가된 메서드가 자동으로 포함될 것이고, 부가기능은 `invoke()` 메서드에서 처리된다.

### 6.3.3 다이나믹 프록시를 이용한 트랜잭션 부가기능

- 다음 단점을 해결하기 위해 `UserServiceTx`를 다이나믹 프록시 방식으로 변경한다.
    - 인터페이스의 모든 메서드를 구현해야 한다.
    - 트랜잭션이 필요한 메서드마다 트랜잭션 처리 코드가 중복돼서 나타난다.
- 트랜잭션 `InvocationHandler`(소스 참고)
- `TransactionHandler`와 다이나믹 프록시를 이용하는 테스트
    ```java
    @Test
    void upgradeAllOrNothing() throws Exception {
        // ...

        TransactionHandler txHandler = new TransactionHandler();
        txHandler.setTarget(testUserService);
        txHandler.setTransactionManager(transactionManager);
        txHandler.setPattern("upgradeLevels");
        UserService txUserService = (UserService) Proxy.newProxyInstance(
                getClass().getClassLoader(),
                new Class[]{UserService.class},
                txHandler
        );

        // ...
    }
    ```

### 6.3.4 다이나믹 프록시를 위한 팩토리 빈

- DI의 대상이 되는 다이나믹 프록시 객체를 스프링 빈으로 등록할 방법이 없다.
- 스프링은 지정된 클래스의 이름을 가지고 리플렉션을 이용해 해당 클래스의 객체를 만든다.
    - `Class.newInstance()` 메서드는 해당 클래스의 파라미터가 없는 생성자를 호출한다.
- 팩토리 빈
    - 스프링은 클래스 정보를 가지고 빈을 만들 수 있는 여러 가지 방법을 제공한다.
    - 팩토리 빈을 이용한 방법이 대표적이다.
        - 팩토리 빈은 스프링을 대신해서 객체의 생성 로직을 담당하도록 만들어진 특별한 빈이다.
        - 팩토리 빈을 만드는 간단한 방법은 스프링의 `FactoryBean` 인터페이스를 구현하는 것이다.
- 팩토리 빈의 설정(소스 참고)
    ```xml
    <bean id="userService" class="study.user.service.TxProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="transactionManager" ref="transactionManager"/>
        <property name="pattern" value="upgradeLevels"/>
        <property name="serviceInterface" value="study.user.service.UserService"/>
    </bean>
    ```
- 다이나믹 프록시를 만들어주는 팩토리 빈
    - 팩토리 빈의 `getObject()` 메서드에 다이나믹 프록시 객체를 만들어주는 코드를 넣으면 스프링 빈으로 만들 수 있다.
- 트랜잭션 프록시 팩토리 빈(소스 참고)
- 트랜잭션 프록시 팩토리 빈 테스트(소스 참고)

### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

- 프록시 팩토리 빈의 재사용
    - 타깃 객체에 맞는 프로퍼티 정보를 설정해서 빈으로 등록해주기만 하면 다양한 클래스에 적용할 수 있다.
- 프록시 팩토리 빈 방식의 장점
    - 프록시 팩토리 빈은 프록시 작성의 두 가지 문제를 해결해준다.
        - 인터페이스 구현 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
        - 하나의 핸들러 메서드 구현으로 다양한 메서드에 부가기능을 부여할 수 있다.
        - 프록시 팩토리 빈을 이용한 DI를 활용하면 다이나믹 프록시 생성 코드도 제거할 수 있다.
- 프록시 팩토리 빈의 한계
    - 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공할 수 없다.
    - 하나의 타깃에 여러 개의 부가기능을 적용할 때 설정 파일에 설정 코드가 복잡해질 수 있다.
    - `TransactionHandler` 객체가 프록시 팩토리 빈 개수만큼 만들어진다.

## 6.4 스프링의 프록시 팩토리 빈

### 6.4.1 `ProxyFactoryBean`

- 스프링은 일관된 방법으로 프록시를 만들 수 있도록 프록시 기술에도 서비스 추상화를 적용한다.
- 생성된 프록시는 스프링의 빈으로 등록돼야 한다.
- 스프링의 `ProxyFactoryBean`은 프록시를 생성해서 빈 객체로 등록하게 해주는 팩토리 빈이다.
- `ProxyFactoryBean`은 순수하게 프록시를 생성하는 작업만 담당하고, 부가기능은 별도의 빈에 둘 수 있다.
- 프록시에서 사용할 부가기능은 `MethodInterceptor` 인터페이스를 구현해서 만든다.
    - `MethodInterceptor`는 `InvocationHandler`와 달리 `ProxyFactoryBean`으로부터 타깃 객체에 대한 정보도 함께 제공받는다.
        - 타깃이 다른 여러 프록시에서 함께 사용할 수 있다.
        - 싱글톤 빈으로 등록 가능하다.
- 어드바이스: 타깃이 필요 없는 순수한 부가기능(소스 참고)
    - `MethodInterceptor`는 부가기능을 제공하는 데만 집중할 수 있다.
    - `MethodInterceptor` 구현 클래스는 템플릿, `MethodInvocation`는 콜백 처럼 동작한다.
        - `MethodInterceptor`는 타깃 메서드의 호출이 필요하면 `MethodInvocation.proceed()` 메서드를 호출하면 된다.
    - `addAdvice()` 메서드를 통해 여러 개의 `MethodInterceptor`를 추가할 수 있다.
        - 스프링에서는 객체의 적용하는 부가기능을 담은 객체를 어드바이스(Advice)라고 한다.
    - 스프링의 `ProxyFactoryBean`은 인터페이스 자동검출 기능을 사용해 타깃 객체가 구현하고 있는 인터페이스를 동일하게 구현하는 프록시를 만들어 준다.
- 포인트컷: 부가기능 적용 대상 메서드 선정 방법
    - `TxProxyFactoryBean`의 `pattern`과 같이 `Methodlnterceptor`는 부가기능을 제공할 메서드 선정 기능을 넣을 수 없다.
        - 여러 프록시가 공유해서 사용하기 위해 타깃 정보를 갖지 않도록 만들었다.
        - `Methodlnterceptor`는 스프링의 싱글톤 빈으로 등록될 수 있다.
        - 트랜잭션 적용 메서드 패턴을 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 `Methodlnterceptor`에 메서드 선정 기능을 넣으면 문제가 된다.
    - 스프링의 `ProxyFactoryBean` 방식 확장 기능
        - 어드바이스(Advice): 부가기능을 제공하는 객체
        - 포인트컷(Pointcut): 메서드 선정 알고리즘을 담은 객체
    - 스프링의 `ProxyFactoryBean` 동작 흐름
        - 클라이언트로부터 요청을 받은 프록시는 포인트컷을 통해 부가기능을 부여한 메서드인지 확인한다.
        - 적용 대상이라면 `MethodInterceptor` 타입의 어드바이스를 호출한다.
        - 실제 타깃 객체의 레퍼런스를 가지고, 메서드를 직접 호출하는 것은 `Invocation` 콜백의 역할이다.
    - 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하도록 한 것은 전형적인 전략 패턴의 구조다.
        - 부가기능 방식이나 메서드 선정 알고리즘이 변경 시, 설정만 수정하면 된다.
        - 기존 코드의 변경 없이 확장이 가능한 OCP를 지키는 구조다.
    - 포인트 컷을 적용한 테스트 작성(소스 참고)
        - 포인트컷을 별개의 객체로 묶어서 등록하는 이유
            - `ProxyFactoryBean`은 여러 개의 어드바이스와 포인트컷이 추가될 수 있다.
            - 어떤 어드바이스(부가기능)에 어떤 포인트컷(메서드 선정)을 적용해야할지 애매하기 때문에 `Advisor` 타입의 객체에 담아서 등록해야 한다.
        - 어드바이스와 포인트컷을 묶은 객체를 어드바이저라고 한다.
            - 어드바이저 = 포인트컷(메서드 선정 알고리즘) + 어드바이스(부가기능)

### 6.4.2 `ProxyFactoryBean` 적용

- `TransactionAdvicd`(소스 참고)
- 스프링 XML 설정 파일(소스 참고)
    ```xml
    <bean id="transactionAdvice" class="study.user.service.TransactionAdvice">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="userService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="interceptorNames">
            <list>
                <value>transactionAdvice</value>
            </list>
        </property>
    </bean>
    ```
- 테스트(소스 참고)
- 어드바이스와 포인트컷의 재사용
    - `ProxyFactoryBean`은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.
    - 어드바이스와 포인트컷을 독립적인 객체로 분리하여 여러 프록시가 공유할 수 있다.
    - 트랜잭션 부가기능(`TransactionAdvice`)을 다양한 서비스 클래스에서 재사용할 수 있다.

## 6.5 스프링 AOP

- 지금까지 트랜잭션 코드를 효과적으로 분리했고, 분리해낸 트랜잭션 코드는 기존 설계와 코드에는 영향을 주지 않는다.

### 6.5.1 자동 프록시 생성

- 필요한 타깃 객체마다 비슷한 내용의 `ProxyFactoryBean` 빈 설정정보를 추가해야하는 문제가 남아있다.
- 중복 문제의 접근 방법
    - JDBC try/catch/finally 블록으로 구성된 코드는 전략 패턴과 DI를 적용해서 해결했다.
    - 반복적인 위임 코드가 필요한 프록시 클래스는 런타임 코드 자동생성 기법인 다이나믹 프록시를 통해 해결했다.
    - 하지만 한 번에 여러 개의 빈에 프록시를 일괄 적용할 방법은 없다.
- 빈 후처리기를 이용한 자동 프록시 생성기
    - 스프링은 컨테이너로서 제공하는 기능 중 핵심적인 부분 외에는 확장할 수 있도록 확장 포인트를 제공한다.
    - 그 중 빈 후처리기는 스프링 빈 객체가 만들어지고 난 후에, 빈 객체를 가공할 수 있게 해준다.
    - `DefaultAdvisorAutoProxyCreator`는 어드바이저를 이용한 자동 프록시 생성 빈 후처리기다.
        - 스프링이 생성하는 빈 객체의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수 있다.
    - 자동 프록시 생성 방법
        - 스프링은 빈 객체를 만들 때마다 `DefaultAdvisorAutoProxyCreator` 빈 후처리기에게 빈을 전달한다.
        - 등록된 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
        - 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
        - 프록시가 생성되면 스프링 컨테이너에게 프록시 객체를 돌려준다.
    - 빈 후처리기를 사용하면 매번 `ProxyFactoryBean` 빈을 등록하지 않아도 타깃 객체에 프록시를 적용할 수 있다.
- 확장된 포인트컷
    - 포인트컷의 기능
        - `getClassFilter()`: 프록시를 적용할 클래스인지 확인해준다.
        - `getMethodMatcher()`: 어드바이스를 적용할 메서드인지 확인해준다.
    - `ProxyFactoryBean`에서는 클래스 레벨의 필터는 필요 없었지만, `DefaultAdvisorAutoProxyCreator`는 클래스와 메소드 선정을 모두 지원하는 포인트컷을 갖춘 어드바이저가
      필요하다.
- 포인트컷 테스트(소스 참고)

### 6.5.2 `DefaultAdvisorAutoProxyCreator`의 적용

- 클래스 필터를 적용한 포인트컷 작성(소스 참고)
- 어드바이저를 이용하는 자동 프록시 생성기 등록(소스 참고)
    - `DefaultAdvisorAutoProxyCreator`는 `Advisor` 인터페이스를 구현한 빈을 모두 찾는다.
- `ProxyFactoryBean` 제거와 서비스 빈의 원상복구(소스 참고)
- 자동 프록시 생성기를 사용하는 테스트(소스 참고)
    - 정적 멤버 클래스를 지정할 때는 `$` 기호를 사용한다.
    - `<bean>` 태그의 `parent` 속성을 사용하면 다른 빈 설정의 내용을 상속받을 수 있다.
- 자동생성 프록시 확인
    - 자동화 기술은 직접 확인해보는 습관을 들이는게 좋다.
    - 확인 사항
        - 트랜잭션 부가기능 적용 여부
            - 트랜잭션 경계가 설정된 메서드 실행 후 예외 발생 시 롤백 되는지 확인한다.
        - 조건에 맞는 빈에만 적용되는지 확인
            - `getBean("userService")`로 가져온 객체가 JDK의 `Proxy` 타입인지 확인한다.

### 6.5.3 포인트컷 표현식을 이용한 포인트컷

- 지금까지 메서드나 클래스의 이름을 비교해서 선정하는 방식을 사용했다.
- 스프링은 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있는 방법을 제공한다.
- 이것을 포인트컷 표현식(Pointcut Expression)이라고 한다.
- 포인트컷 표현식
    - `AspectJExpressionPointcut` 클래스를 통해 포인트컷 표현식을 적용할 수 있다.
        - `AspectJExpressionPointcut`는 기존 `Pointcut` 인터페이스와 달리 클래스와 메서드의 선정 알고리즘을 포인트컷 표현식을 사용해 한 번에 지정할 수 있게 해준다.
    - 포인트컷 표현식은 정규식처럼 간단한 문자열로 복잡한 선정조건을 만들어낼 수 있다.
- 포인트컷 표현식 문법
    - 포인트컷 지시자 중 대표적으로 `execution()`가 사용된다.
        - `[]`: 옵션 항목으로 생략 가능하다.
        - `|`: OR 조건이다.
        ```text
        execution([접근 제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외 패턴])
        ```
        - 실제 `Target.minus()` 메서드의 풀 시그니처와 비교
            ```text
            public int springbook.learningtest.spring.pointcut.Target.minus(int,int) throws java.lang.RuntimeException
            ```
            - `public`
                - 접근 제한자 패턴
            - `int`
                - 반환 타입 패턴
            - `springbook.learningtest.spring.pointcut.Target`
                - 패키지와 타입 이름을 포함한 클래스의 타입 패턴
                - 생략하면 모든 타입에 대해 허용한다.
                - 메서드 이름 패턴과 `.`으로 연결된다.
                - 패키지 이름과 클래스 또는 인터페이스 이름에 `*`를 사용할 수 있고, `..`을 통해 한 번에 여러 개의 패키지를 선택할 수 있다.
            - `minus`
                - 메서드 이름 패턴
                - 모든 메서드를 선택하려면 `*`를 사용하면 된다.
            - `(int,int)`
                - 메서드 파라미터의 타입 패턴
                - 파라미터가 없는 메서드를 지정하려면 `()`로, 파라미터의 타입과 개수 상관없이 모두 허용한다면 `..`을 사용하면 된다.
            - `throws java.lang.RuntimeException`
                - 예외 이름에 대한 타입 패턴
- 포인트컷 표현식 테스트
