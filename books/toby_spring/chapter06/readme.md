# 6장 AOP

- AOP(Aspect-Oriented Programming)는 IoC/DI, 서비스 추상화와 함께 스프링의 3대 핵심 기반 기술 중 하나
- AOP는 용어와 개념이 다소 어려워 충분한 이해가 뒷받침될 때 효과적으로 활용할 수 있다.
- 스프링에서 대표적으로 AOP가 적용된 사례는 선언적 트랜잭션 관리이다.

## 6.1 트랜잭션 코드의 분리

- `UserService`는 트랜잭션 기술에 독립적이고, 메일 발송 기술과 환경에 종속되지 않도록 다듬어 왔다.
- 하지만 트랜잭션 경계 설정을 위한 코드가 존재한다.

### 6.1.1 메서드 분리

- 비즈니스 로직과 트랜잭션을 담당하는 두 가지 종류의 코드가 구분되어 있다.
- 두 코드 간에 주고받는 정보가 없다.
- 메서드 추출을 통해 독립시킬 수 있다.(소스 참고)

### 6.1.2 DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService`에 존재한다.
- DI 적용을 이용한 트랜잭션 분리
    - 현재 `UserService` 클래스와 클라이언트 간의 관계가 강한 결합도로 고정되어 있다.
        - 트랜잭션 코드를 `UserService` 밖으로 빼버리면 클라이언트는 트랜잭션 기능이 빠진 `UserService`를 사용하게 된다.
    - 인터페이스와 DI를 적용하면 클라이언트와 결합이 약해지고, 유연한 확장이 가능해진다.
- `UserService` 인터페이스 도입(소스 참고)
- 분리된 트랜잭션 기능(소스 참고)
- 트랜잭션 적용을 위한 DI 설정(소스 참고)
- 트랜잭션 분리에 따른 테스트 수정(소스 참고)
    - `@Autowired`는 기본적으로 타입이 일치하는 빈을 찾아준다.
- 트랜잭션 경계설정 코드 분리의 장점
    - 비즈니스 로직을 담당하고 있는 `UserServiceImpl`는 트랜잭션과 같은 기술적인 내용은 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 작은 단위로 쪼개서 테스트하는 것이다.
    - 테스트가 실패했을 때 원인을 찾기 쉽다.
    - 테스트의 의도나 내용이 분명해진다.
    - 테스트를 작성하기 쉽다.

### 6.2.1 복잡한 의존관계 속의 테스트

- 현재 `UserService`는 세 가지 의존 객체가 필요하다.
    - `UserDao`
    - `MailSender`
    - `PlatformTransactionManager`
- 세 가지 의존 객체들은 테스트가 진행되는 동안 JDBC, 네트워크, 메일 서버 등 함께 테스트 된다.
    - 테스트를 준비하기 힘들다.
    - 환경이 달라지면 동일한 테스트 결과를 받지 못할 수 있다.
    - 테스트 수행 속도가 느리다.

### 6.2.2 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향 받지 않도록 고립시킬 필요가 있다.
- 테스트를 위한 `UserServiceImpl` 고립
    - `UserDao`는 테스트 결과를 검증하기 위한 목 객체로 작성한다.
- 고립된 단위 테스트 활용
    - `UserDao`를 통해 테스트에 필요한 정보를 DB에 넣기위해 준비한다.
    - `MailSender` 목 객체 DI를 통해 의존 객체와 서버 등에서 고립시킨다.
- `UserDao` 목 객체(소스 참고)
    - 사용하지 않는 메서드는 실수로 사용되지 않도록 `UnsupportedOperationException` 예외가 발생하도록 만드는 것을 권장한다.
- 테스트 수행 성능의 향상
    - 의존 대상으로부터 고립된 테스트를 통해 수행 속도가 빨라졌다.

### 6.2.3 단위 테스트와 통합 테스트

- 단위 테스트의 단위는 정하기 나름이지만, 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다.
- 단위 테스트
    - 테스트 대역을 통해 의존 객체나 외부 리소스를 사용하지 않는 고립된 테스트
- 통합 테스트
    - 두 개 이상의 성격이나 계층이 다른 객체가 연동하고록 만들거나 외부 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트를 결정하는 가이드라인
    - 항상 단위 테스트를 먼저 고려한다.
    - 단위 테스트는 외부 의존성을 차단하고, 빠르고 효과적으로 작성할 수 있다.
    - 외부 리소스가 필요한 테스트는 통합 테스트로 작성한다.
    - DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하는 DAO는 고립된 테스트 작성이 어렵고, 가치가 없기 때문에 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
    - DAO와 같이 DB 연동이 필수인 코드는 통합 테스트로 분류한다.
    - DAO를 충분히 검증해두면, DAO를 이용하는 코드는 스텁이나 목 객체로 대체해 테스트할 수 있다.
    - 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
    - 충분한 단위 테스트를 거친다면 통합 테스트의 부담은 상대적으로 줄어든다.
    - 단위 테스트가 너무 복잡하면 처음부터 통합 테스트를 고려해야 하지만, 가능한 많은 부분을 미리 단위 테스트로 검증하는 것이 유리하다.
    - 스프링 테스트 컨텍스트 프레임워크를 사용하는 테스트는 통합 테스트에 해당한다.
    - 가능하다면 스프링 없이 코드 레벨에서 단위 테스트를 작성하고, 스프링 설정이나 추상적 레벨의 테스트가 필요할 경우 스프링 테스트 컨텍스트 프레임워크를 이용한 통합 테스트를 작성한다.
- 스프링이 권장하는 유연한 코드를 만들다보면 테스트도 만들기 쉬워지고, 테스트는 리팩토링과 개선을 통해 코드의 품질을 높여준다.

### 6.2.4 목 프레임워크

- 단위 테스트에서 목 객체를 만드는일은 번거롭다.
- 목 객체를 편리하게 작성하도록 도와주는 다양한 목 객체 지원 프레임워크가 있다.
- Mockito 프레임워크
    - 목 클래스를 일일히 준비해둘 필요가 없다는 특징을 가지고 있다.
    - `org.mockito.Matchers` 클래스에 정의된 스태틱 메소드를 제공한다.
    - Mockito를 이용한 테스트 코드(소스 참고)

## 6.3 다이나믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

- 트랜잭션 경계설정 코드 분리
    - 트랜잭션을 적용하는 부가기능을 핵심기능이 담긴 클래스에서 독립 시켰다.
    - 부가기능 코드에서는 핵심기능으로 요청을 위힘해주는 과정에서 부가적인 기능을 적용해줄 수 있다.
    - 클라이언트는 인터페이스로 접근하기 때문에 핵심기능을 가진 클래스를 기대하고 사용한다.
    - 프록시(Proxy): 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자, 대리인과 같은 역할
    - 타깃(Target) 또는 실체(Real Subject): 프록시를 통해 요청을 위임받아 처리하는 실제 객체
    - 프록시의 목적
        - 클라이언트가 타깃에 접근하는 방법을 제어한다.
        - 타깃에 부가적인 기능을 부여해 준다.
- 데코레이터 패턴
    - 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
        - 다이나믹하게 기능을 부가한다는 의미는 컴파일 시점에는 어떤 방법과 순서로 프록시와 타깃이 정해져 있지 않는 것을 뜻한다.
    - 데코레이터 패턴에서는 여러 개의 프록시를 사용할 수 있다.
    - 프록시로 동작하는 각 데코테이터는 위임하는 대상에 인터페이스로 접근한다.
        - 위임 대상이 최종 타깃인지 다음 데코레이터 프록시인지 알 수 없다.
        - `UserServiceTx`는 데코레이터, `UserServiceImple`은 타깃이 된다.
    - 데코레이터 패턴은 타깃의 코드와 클라이언트사 호출 방법을 변경하지 않고 새로운 기능을 추가할 때 유용한 방법이다.
- 프록시 패턴
    - 일반적으로 프록시는 클라이언트와 사용 대상 사이에 대리 역할을 맡는 객체를 두는 방법을 총칭한다.
    - 프록시 패턴은 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가르킨다.
    - 프록시 패턴은 타깃의 기능 자체에는 관여하지 않고 접근하는 방법을 제어해주는 프록시를 이용하는 방법이다.

### 6.3.2 다이나믹 프록시

- 프록시 패턴을 기존 코드에 영향을 주지 않으면서 타깃의 기능을 확장하거나 접근 방법을 제어할 수 있는 유용한 방법이다.
- 하지만 매번 새로운 클래스를 정의해야하고, 인터페이스의 모든 메서드를 구현해야하는 번거로움이 있다.
- 프록시의 구성과 프록시 작성의 문제점
    - 프록시의 기능
        - 타깃과 같은 메서드를 구현하고 있다가 메서드가 호출되면 타깃 객체로 위임한다.
        - 지정된 요청에 대해서는 부가기능을 수행한다.
    - 프록시 작성의 문제점
        - 타깃의 인터페이스를 구현하고 위임하는 코드를 작성하기 번거롭다.
            - 부가기능이 필요 없는 메서드도 타깃으로 위임하는 코드를 일일이 만들어줘야 한다.
        - 부가기능 코드가 중복될 가능성이 있다.
- 리플렉션
    - 다이나믹 프록시는 리플렉션 기능을 이용해서 프록시를 만들어준다.
    - 리플렉션은 자바의 코드 자체를 추상화해서 접근하도록 만든 기능이다.
    - 리플렉션 학습 테스트(소스 참고)
- 프록시 클래스(소스 참고)
- 다이나믹 프록시 적용(소스 참고)
    - 프록시 팩토리에 의해 런타임 시 다이나믹하게 만들어지는 객체
    - 다이나믹 프록시는 클라이언트의 모든 요청을 리플렉션 정보로 변환해서 `InvocationHandler` 구현 객체의 `invoke()` 메서드로 넘긴다.
        - 타깃 인터페이스의 모든 메서드 요청이 하나의 메서드로 집중되기 때문에 중복되는 기능을 효과적으로 제공할 수 있다.
    - 메서드와 파라미터 정보를 모두 알고 있기 때문에 리플렉션으로 타깃 객체의 메서드를 호출할 수 있다.
    - `Proxy.newProxyInstance()` 정적 팩토리 메서드를 통해 다이나믹 프록시를 생성할 수 있다.
- 다이나믹 프록시의 확장(소스 참고)
    - `Hello` 인터페이스의 메서드가 30개로 늘어난다면, 직접 구현한 프록시는 매번 코드를 추가해야 한다.
    - 다이나믹 프록시는 추가된 메서드가 자동으로 포함될 것이고, 부가기능은 `invoke()` 메서드에서 처리된다.

### 6.3.3 다이나믹 프록시를 이용한 트랜잭션 부가기능

- 다음 단점을 해결하기 위해 `UserServiceTx`를 다이나믹 프록시 방식으로 변경한다.
    - 인터페이스의 모든 메서드를 구현해야 한다.
    - 트랜잭션이 필요한 메서드마다 트랜잭션 처리 코드가 중복돼서 나타난다.
- 트랜잭션 `InvocationHandler`(소스 참고)
- `TransactionHandler`와 다이나믹 프록시를 이용하는 테스트
    ```java
    @Test
    void upgradeAllOrNothing() throws Exception {
        // ...

        TransactionHandler txHandler = new TransactionHandler();
        txHandler.setTarget(testUserService);
        txHandler.setTransactionManager(transactionManager);
        txHandler.setPattern("upgradeLevels");
        UserService txUserService = (UserService) Proxy.newProxyInstance(
                getClass().getClassLoader(),
                new Class[]{UserService.class},
                txHandler
        );

        // ...
    }
    ```

### 6.3.4 다이나믹 프록시를 위한 팩토리 빈

- DI의 대상이 되는 다이나믹 프록시 객체를 스프링 빈으로 등록할 방법이 없다.
- 스프링은 지정된 클래스의 이름을 가지고 리플렉션을 이용해 해당 클래스의 객체를 만든다.
    - `Class.newInstance()` 메서드는 해당 클래스의 파라미터가 없는 생성자를 호출한다.
- 팩토리 빈
    - 스프링은 클래스 정보를 가지고 빈을 만들 수 있는 여러 가지 방법을 제공한다.
    - 팩토리 빈을 이용한 방법이 대표적이다.
        - 팩토리 빈은 스프링을 대신해서 객체의 생성 로직을 담당하도록 만들어진 특별한 빈이다.
        - 팩토리 빈을 만드는 간단한 방법은 스프링의 `FactoryBean` 인터페이스를 구현하는 것이다.
- 팩토리 빈의 설정(소스 참고)
    ```xml
    <bean id="userService" class="study.user.service.TxProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="transactionManager" ref="transactionManager"/>
        <property name="pattern" value="upgradeLevels"/>
        <property name="serviceInterface" value="study.user.service.UserService"/>
    </bean>
    ```
- 다이나믹 프록시를 만들어주는 팩토리 빈
    - 팩토리 빈의 `getObject()` 메서드에 다이나믹 프록시 객체를 만들어주는 코드를 넣으면 스프링 빈으로 만들 수 있다.
- 트랜잭션 프록시 팩토리 빈(소스 참고)
- 트랜잭션 프록시 팩토리 빈 테스트(소스 참고)

### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

- 프록시 팩토리 빈의 재사용
    - 타깃 객체에 맞는 프로퍼티 정보를 설정해서 빈으로 등록해주기만 하면 다양한 클래스에 적용할 수 있다.
- 프록시 팩토리 빈 방식의 장점
    - 프록시 팩토리 빈은 프록시 작성의 두 가지 문제를 해결해준다.
        - 인터페이스 구현 클래스를 일일이 만드는 번거로움을 제거할 수 있다.
        - 하나의 핸들러 메서드 구현으로 다양한 메서드에 부가기능을 부여할 수 있다.
        - 프록시 팩토리 빈을 이용한 DI를 활용하면 다이나믹 프록시 생성 코드도 제거할 수 있다.
- 프록시 팩토리 빈의 한계
    - 한 번에 여러 개의 클래스에 공통적인 부가기능을 제공할 수 없다.
    - 하나의 타깃에 여러 개의 부가기능을 적용할 때 설정 파일에 설정 코드가 복잡해질 수 있다.
    - `TransactionHandler` 객체가 프록시 팩토리 빈 개수만큼 만들어진다.

## 6.4 스프링의 프록시 팩토리 빈

### 6.4.1 `ProxyFactoryBean`

- 스프링은 일관된 방법으로 프록시를 만들 수 있도록 프록시 기술에도 서비스 추상화를 적용한다.
- 생성된 프록시는 스프링의 빈으로 등록돼야 한다.
- 스프링의 `ProxyFactoryBean`은 프록시를 생성해서 빈 객체로 등록하게 해주는 팩토리 빈이다.
- `ProxyFactoryBean`은 순수하게 프록시를 생성하는 작업만 담당하고, 부가기능은 별도의 빈에 둘 수 있다.
- 프록시에서 사용할 부가기능은 `MethodInterceptor` 인터페이스를 구현해서 만든다.
    - `MethodInterceptor`는 `InvocationHandler`와 달리 `ProxyFactoryBean`으로부터 타깃 객체에 대한 정보도 함께 제공받는다.
        - 타깃이 다른 여러 프록시에서 함께 사용할 수 있다.
        - 싱글톤 빈으로 등록 가능하다.
- 어드바이스: 타깃이 필요 없는 순수한 부가기능(소스 참고)
    - `MethodInterceptor`는 부가기능을 제공하는 데만 집중할 수 있다.
    - `MethodInterceptor` 구현 클래스는 템플릿, `MethodInvocation`는 콜백 처럼 동작한다.
        - `MethodInterceptor`는 타깃 메서드의 호출이 필요하면 `MethodInvocation.proceed()` 메서드를 호출하면 된다.
    - `addAdvice()` 메서드를 통해 여러 개의 `MethodInterceptor`를 추가할 수 있다.
        - 스프링에서는 객체의 적용하는 부가기능을 담은 객체를 어드바이스(Advice)라고 한다.
    - 스프링의 `ProxyFactoryBean`은 인터페이스 자동검출 기능을 사용해 타깃 객체가 구현하고 있는 인터페이스를 동일하게 구현하는 프록시를 만들어 준다.
- 포인트컷: 부가기능 적용 대상 메서드 선정 방법
    - `TxProxyFactoryBean`의 `pattern`과 같이 `Methodlnterceptor`는 부가기능을 제공할 메서드 선정 기능을 넣을 수 없다.
        - 여러 프록시가 공유해서 사용하기 위해 타깃 정보를 갖지 않도록 만들었다.
        - `Methodlnterceptor`는 스프링의 싱글톤 빈으로 등록될 수 있다.
        - 트랜잭션 적용 메서드 패턴을 프록시마다 다를 수 있기 때문에 여러 프록시가 공유하는 `Methodlnterceptor`에 메서드 선정 기능을 넣으면 문제가 된다.
    - 스프링의 `ProxyFactoryBean` 방식 확장 기능
        - 어드바이스(Advice): 부가기능을 제공하는 객체
        - 포인트컷(Pointcut): 메서드 선정 알고리즘을 담은 객체
    - 스프링의 `ProxyFactoryBean` 동작 흐름
        - 클라이언트로부터 요청을 받은 프록시는 포인트컷을 통해 부가기능을 부여한 메서드인지 확인한다.
        - 적용 대상이라면 `MethodInterceptor` 타입의 어드바이스를 호출한다.
        - 실제 타깃 객체의 레퍼런스를 가지고, 메서드를 직접 호출하는 것은 `Invocation` 콜백의 역할이다.
    - 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하도록 한 것은 전형적인 전략 패턴의 구조다.
        - 부가기능 방식이나 메서드 선정 알고리즘이 변경 시, 설정만 수정하면 된다.
        - 기존 코드의 변경 없이 확장이 가능한 OCP를 지키는 구조다.
    - 포인트 컷을 적용한 테스트 작성
        - 포인트컷을 별개의 객체로 묶어서 등록하는 이유
            - `ProxyFactoryBean`은 여러 개의 어드바이스와 포인트컷이 추가될 수 있다.
            - 어떤 어드바이스(부가기능)에 어떤 포인트컷(메서드 선정)을 적용해야할지 애매하기 때문에 `Advisor` 타입의 객체에 담아서 등록해야 한다.
        - 어드바이스와 포인트컷을 묶은 객체를 어드바이저라고 한다.
            - 어드바이저 = 포인트컷(메서드 선정 알고리즘) + 어드바이스(부가기능)

### 6.4.2 `ProxyFactoryBean` 적용

- `TransactionAdvicd`(소스 참고)
- 스프링 XML 설정 파일(소스 참고)
    ```xml
    <bean id="transactionAdvice" class="study.user.service.TransactionAdvice">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="transactionPointcut" class="study.user.service.NameMatchClassMethodPointcut">
        <property name="mappedClassName" value="*ServiceImpl"/>
        <property name="mappedName" value="upgrade*"/>
    </bean>

    <bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
        <property name="advice" ref="transactionAdvice"/>
        <property name="pointcut" ref="transactionPointcut"/>
    </bean>

    <bean id="userService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="interceptorNames">
            <list>
                <value>transactionAdvisor</value>
            </list>
        </property>
    </bean>
    ```
- 테스트(소스 참고)
- 어드바이스와 포인트컷의 재사용
    - `ProxyFactoryBean`은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.
    - 어드바이스와 포인트컷을 독립적인 객체로 분리하여 여러 프록시가 공유할 수 있다.
    - 트랜잭션 부가기능(`TransactionAdvice`)을 다양한 서비스 클래스에서 재사용할 수 있다.

## 6.5 스프링 AOP

- 지금까지 트랜잭션 코드를 효과적으로 분리했고, 분리해낸 트랜잭션 코드는 기존 설계와 코드에는 영향을 주지 않는다.
- 부가기능 적용 후 기존 설계와 코드에 영향을 주지 않는것을 투명하다고 한다.

### 6.5.1 자동 프록시 생성

- 필요한 타깃 객체마다 비슷한 내용의 `ProxyFactoryBean` 빈 설정정보를 추가해야하는 문제가 남아있다.
- 중복 문제의 접근 방법
    - JDBC try/catch/finally 블록으로 구성된 코드는 전략 패턴과 DI를 적용해서 해결했다.
    - 반복적인 위임 코드가 필요한 프록시 클래스는 런타임 코드 자동생성 기법인 다이나믹 프록시를 통해 해결했다.
    - 하지만 한 번에 여러 개의 빈에 프록시를 일괄 적용할 방법은 없다.
- 빈 후처리기를 이용한 자동 프록시 생성기
    - 스프링은 컨테이너로서 제공하는 기능 중 핵심적인 부분 외에는 확장할 수 있도록 확장 포인트를 제공한다.
    - 그 중 빈 후처리기는 스프링 빈 객체가 만들어지고 난 후에, 빈 객체를 가공할 수 있게 해준다.
    - `DefaultAdvisorAutoProxyCreator`는 어드바이저를 이용한 자동 프록시 생성 빈 후처리기다.
        - 스프링이 생성하는 빈 객체의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수 있다.
    - 자동 프록시 생성 방법
        - 스프링은 빈 객체를 만들 때마다 `DefaultAdvisorAutoProxyCreator` 빈 후처리기에게 빈을 전달한다.
        - 등록된 어드바이저 내의 포인트컷을 이용해 전달받은 빈이 프록시 적용 대상인지 확인한다.
        - 적용 대상이면 내장된 프록시 생성기에게 현재 빈에 대한 프록시를 만들게 하고, 만들어진 프록시에 어드바이저를 연결해준다.
        - 프록시가 생성되면 스프링 컨테이너에게 프록시 객체를 돌려준다.
    - 빈 후처리기를 사용하면 매번 `ProxyFactoryBean` 빈을 등록하지 않아도 타깃 객체에 프록시를 적용할 수 있다.
- 확장된 포인트컷
    - 포인트컷의 기능
        - `getClassFilter()`: 프록시를 적용할 클래스인지 확인해준다.
        - `getMethodMatcher()`: 어드바이스를 적용할 메서드인지 확인해준다.
    - `ProxyFactoryBean`에서는 클래스 레벨의 필터는 필요 없었지만, `DefaultAdvisorAutoProxyCreator`는 클래스와 메소드 선정을 모두 지원하는 포인트컷을 갖춘 어드바이저가
      필요하다.
- 포인트컷 테스트(소스 참고)

### 6.5.2 `DefaultAdvisorAutoProxyCreator`의 적용

- 클래스 필터를 적용한 포인트컷 작성(소스 참고)
- 어드바이저를 이용하는 자동 프록시 생성기 등록(소스 참고)
    - `DefaultAdvisorAutoProxyCreator`는 `Advisor` 인터페이스를 구현한 빈을 모두 찾는다.
- `ProxyFactoryBean` 제거와 서비스 빈의 원상복구(소스 참고)
- 자동 프록시 생성기를 사용하는 테스트(소스 참고)
    - 정적 멤버 클래스를 지정할 때는 `$` 기호를 사용한다.
    - `<bean>` 태그의 `parent` 속성을 사용하면 다른 빈 설정의 내용을 상속받을 수 있다.
- 자동생성 프록시 확인
    - 자동화 기술은 직접 확인해보는 습관을 들이는게 좋다.
    - 확인 사항
        - 트랜잭션 부가기능 적용 여부
            - 트랜잭션 경계가 설정된 메서드 실행 후 예외 발생 시 롤백 되는지 확인한다.
        - 조건에 맞는 빈에만 적용되는지 확인
            - `getBean("userService")`로 가져온 객체가 JDK의 `Proxy` 타입인지 확인한다.

### 6.5.3 포인트컷 표현식을 이용한 포인트컷

- 지금까지 메서드나 클래스의 이름을 비교해서 선정하는 방식을 사용했다.
- 스프링은 일종의 표현식 언어를 사용해서 포인트컷을 작성할 수 있는 방법을 제공한다.
- 이것을 포인트컷 표현식(Pointcut Expression)이라고 한다.
- 포인트컷 표현식
    - `AspectJExpressionPointcut` 클래스를 통해 포인트컷 표현식을 적용할 수 있다.
        - `AspectJExpressionPointcut`는 기존 `Pointcut` 인터페이스와 달리 클래스와 메서드의 선정 알고리즘을 포인트컷 표현식을 사용해 한 번에 지정할 수 있게 해준다.
    - 포인트컷 표현식은 정규식처럼 간단한 문자열로 복잡한 선정조건을 만들어낼 수 있다.
- 포인트컷 표현식 문법
    - 포인트컷 지시자 중 대표적으로 `execution()`가 사용된다.
        - `[]`: 옵션 항목으로 생략 가능하다.
        - `|`: OR 조건이다.
        ```text
        execution([접근 제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외 패턴])
        ```
        - 실제 `Target.minus()` 메서드의 풀 시그니처와 비교
            ```text
            public int springbook.learningtest.spring.pointcut.Target.minus(int,int) throws java.lang.RuntimeException
            ```
            - `public`
                - 접근 제한자 패턴
            - `int`
                - 반환 타입 패턴
            - `springbook.learningtest.spring.pointcut.Target`
                - 패키지와 타입 이름을 포함한 클래스의 타입 패턴
                - 생략하면 모든 타입에 대해 허용한다.
                - 메서드 이름 패턴과 `.`으로 연결된다.
                - 패키지 이름과 클래스 또는 인터페이스 이름에 `*`를 사용할 수 있고, `..`을 통해 한 번에 여러 개의 패키지를 선택할 수 있다.
            - `minus`
                - 메서드 이름 패턴
                - 모든 메서드를 선택하려면 `*`를 사용하면 된다.
            - `(int,int)`
                - 메서드 파라미터의 타입 패턴
                - 파라미터가 없는 메서드를 지정하려면 `()`로, 파라미터의 타입과 개수 상관없이 모두 허용한다면 `..`을 사용하면 된다.
            - `throws java.lang.RuntimeException`
                - 예외 이름에 대한 타입 패턴
- 포인트컷 표현식 테스트(소스 참고)
- 포인트컷 표현식을 이용하는 포인트컷 적용
    - 포인트컷 표현식을 사용하면 로직이 문자열에 담기기 때문에 코드와 설정이 단순해진다.
    - 하지만 문자열이기 때문에 런타임 시점까지 문법의 검증이나 기능을 확인할 수 없다.
    ```xml
    <bean id="transactionAdvice" class="study.user.service.TransactionAdvice">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="transactionPointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
        <property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))"/>
    </bean>

    <bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
        <property name="advice" ref="transactionAdvice"/>
        <property name="pointcut" ref="transactionPointcut"/>
    </bean>
    ```
- 타입 패턴과 클래스 이름 패턴
    - 포인트컷 표현식 적용 전에는 클래스 이름의 패턴을 이용해 타깃 빈을 선정하는 포인트컷을 사용했다.
        - `TestUserService`는 이름 패턴에 맞추기위해 `TestUserServiceImpl`로 클래스명을 변경했다.
    - 포인트컷 표현식의 클래스 이름에 적용되는 패턴은 타입 패턴이다.
        - `TestUserService`로 다시 클래스 이름을 변경해도 타입은 슈퍼 클래스인 `UserServiceImpl`, 구현 인터페이스인 `UserService` 모두 적용된다.

### 6.5.4 AOP란 무엇인가?

- `UserService`에 트랜잭션을 적용해온 과정
- 트랜잭션 서비스 추상화
    - 특정 트랜잭션 기술에 종속되는 코드로 인해 트랜잭션 방식을 바꾸려면 모든 트랜잭션 적용 코드 수정이 필요했다.
    - 트랜잭션 작업을 추상화하고, 구체적인 구현은 자유롭게 변경할 수 있도록 서비스 추상화 기법을 적용했다.
- 프록시와 데코레이터 패턴
    - 여전히 비즈니스 로직 코드에 트랜잭션을 적용하는 방법이 여전히 코드에 드러나 있다.
    - DI를 이용한 데코레이터 패턴을 통해 비즈니스 로직 클래스에는 영향을 주지 않으면서, 트랜잭션이라는 부가기능을 비즈니스 로직에 적용할 수 있는 구조를 만들었다.
- 다이나믹 프록시와 프록시 팩토리 빈
    - 비즈니스 로직 인터페이스의 모든 메서드에 트랜잭션 기능을 부여하는 코드를 추가해야 했고, 부가기능이 필요하지 않은 메서드조차 프록시로서 위임 기능이 필요했다.
    - JDK 다이나믹 프록시 기술을 적용하여 부가기능 부여 코드가 중복되는 문제를 해결했고, 메서드 선정 패턴을 통해 트랜잭션 적용이 필요한 메서드를 선정할 수 있었다.
- 자동 프록시 생성 방법과 포인트컷
    - 트랜잭션 적용 대상이 되는 빈 모두 프록시 팩토리 빈을 설정이 필요했다.
    - 스프링 컨테이너의 빈 생성 후처리 기법을 통해 프록시를 적용할 대상 패턴을 이용해 자동으로 선정할 수 있도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다.
    - 결국 트랜잭션 부가기능을 어디에 적용하는지에 대한 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다.
- 부가기능의 모듈화
    - 부가기능은 기능을 부가할 대상 없이 스스로 독립적인 방식으로 존재해서는 적용이 어렵다.
    - 애플리케이션 전반에 여기저기 흩어져 있는 트랜잭션 코드를 어드바이스와 포인트컷을 결합한 어드자이저를 사용해 독립적으로 모듈화시켰다.
- AOP: 애스펙트 지향 프로그래밍
    - 객체지향 기술에서는 부가기능 모듈을 애스펙트(Aspect)라고 부른다.
    - 부가기능을 독립적인 애스팩트로 분리하여 핵심기능은 순수하게 그 기능을 담은 코드로 존재할 수 있게 됐다.
    - 애플리케이션에서 핵심기능에서 부가적인 기능을 분리해서 애스펙트로 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍(AOP: Aspect Oriented Programming)이라고 한다.
    - AOP는 새로운 패러다임이 아닌, OOP를 보조하는 기술이다.
        - 핵심기능과 부가기능이 섞이면 객체지향 설계의 장점을 살리기 어렵다.
        - 애스펙트 분리를 통해 핵심기능 설계 시 객체지향적인 가치를 지킬 수 있도록 도와주는 기술이다.
        - 애플리케이션을 다양한 관점에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 도와준다.
    - AOP는 특정한 관점을 기준으로 바라볼 수 있게 해주기 때문에 관점 지향 프로그램이라고도 한다.

### 6.5.5 AOP 적용기술

- 프록시를 이용한 AOP
    - 스프링은 다양한 기술을 조합해서 AOP를 지원하고 있고, 그중 핵심은 프록시를 이용했다는 것이다.
    - 프록시로서 DI로 연결된 빈 사이에서 메서드 호출 과정에 참여해 부가기능을 제공해준다.
    - 애스펙트를 다양한 타깃 메서드에 다이나믹하게 적용하기 위해 프록시는 중요한 역할을 한다.
    - 스프링 AOP는 프록시 방식의 AOP다.
- 바이트코드 생성과 조작을 통한 AOP
    - 프록시 방식이 아닌 AOP 기술도 있다.
        - 대표적으로 AspectJ는 타깃에 직접 부가기능을 넣어주는 방법을 사용한다.
            - 컴파일된 타깃의 클래스 파일 자체를 수정한다.
            - 클래스가 JVM에 로딩되는 시점에 바이트코드를 조작한다.
            - 복잡한 방법을 사용하는 이유
                - 스프링 DI 컨테이너의 도움 없이 AOP를 적용할 수 있다.
                - 바이트코드를 직접 조작하면 메서드뿐만 아니라 프록시 적용이 불가능한 작업에도 부가기능을 부여할 수 있다.
    - 일반적으로 프록시 방식의 스프링 AOP로도 충분하다.
    - 스프링 AOP 수준을 넘어서는 기능이 필요하다면 AspectJ를 함께 사용하면 된다.

### 6.5.6 AOP의 용어

- 타깃
    - 부가기능을 부여할 대상
- 어드바이스
    - 부가기능을 담은 모듈
- 조인 포인트(Join Point)
    - 어드바이스가 적용될 수 있는 위치
    - 스프링의 프록시 AOP에서 조인 포인트는 메서드의 실행 단계뿐이다.
    - 구현한 인터페이스의 모든 메서드는 조인 포인트가 된다.
- 포인트컷
    - 어드바이스를 적용할 조인 포인트를 선별하는 기능을 정의한 모듈
- 프록시
    - 클라이언트와 타깃 사이에 투명하게 부가기능을 제공하는 객체
- 어드바이저
    - 포인트컷과 어드바이스를 하나 씩 갖고 있는 객체
- 애스펙트
    - AOP의 기본 모듈
    - 여러개의 포인트컷과 어드바이스의 조합으로 만들어진다.
    - 일반적으로 싱글톤 형태의 객체로 존재한다.

### 6.5.7 AOP 네임스페이스

- 스프링 AOP를 적용하기 위해 추가했던 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
- 스프링의 프록시 방식 AOP를 적용하려면 최소 4가지 빈이 필요하다.
    - 자동 프록시 생성기
        - 스프링의 `DefaultAdvisorAutoProxyCreator` 클래스를 빈으로 등록한다.
        - DI 하지도, 되지도 않고 독립적으로 존재하기 때문에 ID도 필요하지 않다.
        - 빈 후처리기로 참여해서 빈으로 등록된 어드바이저를 이용해 프록시를 자동으로 생성하는 기능을 담당한다.
    - 어드바이스
        - 부가기능을 구현한 클래스를 빈으로 등록한다.
    - 포인트컷
        - 스프링의 `AspectJExpressionPointcut`을 빈으로 등록하고, `expression` 프로퍼티에 포인트컷 표현식을 넣어주면 된다.
    - 어드바이저
        - 스프링의 `DefaultPointcutAdvisor` 클래스를 빈으로 등록한다.
        - 어드바이스와 포인트컷을 참조하는 것 외에 기능은 없다.
        - 자동 프록시 생성기에 의해 자동 검색되어 사용한다.
    - AOP 네입스페이스
        - 스프링은 AOP와 관련된 태그를 정의해둔 aop 스키마를 제공한다.
            - `<aop:config>`
                - AOP 설정을 담는 부모 태그
                - 필요에 따라 `AbstractAdvisorAutoProxyCreator`를 빈으로 등록한다.
            - `<aop:pointcut>`
                - `expression`의 표현식을 프로퍼티로 가진 `AspectJExpressionPointcut`을 빈으로 등록한다.
            - `<aop:advisor>`
                - 어드바이스와 포인트컷의 참조를 프로퍼티로 갖는 `DefaultBeanFactoryPointcutAdvisor`를 빈으로 등록한다.
        ```xml
        <aop:config>
            <aop:pointcut id="transactionPointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))"/>
            <aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut"/>
        </aop:config>
        ```
    - 어드바이저 내장 포인트컷(소스 참고)
        - 포인트컷을 공유하는 경우 포인트컷을 독립적인 `<aop:pointcut>` 태그로 등록해야 한다.

## 6.6 트랜잭션 속성

- 트랜잭션 추상화에서 트랜잭션을 시작할 때 사용했던 `DefaultTransactionDefinition` 객체에 대해 알아본다.

### 6.6.1 트랜잭션 정의

- 트랜잭션은 다양한 방식으로 동작한다.
    - 더 이상 쪼갤 수 없는 최소 단위의 작업이라는 개념은 항상 유효하기 때문에 `commit()`, `rollback()`을 통해 모두 성공 또는 취소돼야 한다.
- 트랜잭션 전파(Transaction Propagation)
    - 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식이다.
    - 트랜잭션 전바 속성
        - PROPAGATION_REQUIRED
            - 진행 중인 트랜잭션이 있으면 참여하고, 없으면 새로 시작한다.
            - `DefaultTransactionDefinition`의 트랜잭션 전파 속성이다.
        - PROPAGATION_REQUIRES_NEW
            - 항상 새로운 트랜잭션을 시작한다.
            - 독립적인 트랜잭션이 보장돼야 할 때 적용할 수 있다.
        - PROPAGATION_NOT_SUPPORTED
            - 트랜잭션 없이 동작한다.
            - AOP를 이용해 한 번에 많은 메서드를 동시에 적용할 때, 특정 메서드만 트랜잭션 적용에서 제외해야할 때 사용한다.
                - 특정 메서드를 선정에서 제외하는 포인트컷을 만드는 것은 상당히 복잡해질 수 있다.
    - `getTransaction()` 메서드를 사용해도 트랜잭션 전파 속성에 따라 트랜잭션을 시작할 수도, 진행중인 트랜잭션에 참여하기만 할 수도 있다.
- 격리수준(Isolation Level)
    - 여러 트랜잭션이 동시에 진행될 때 격리 수준을 통해 문제가 발생하지 않도록 제어할 수 있다.
        - 모든 트랜잭션이 순차적으로 진행된다면 성능이 떨어질 수 있다.
    - 격리수준 재설정
        - 기본적으로 DB에 설정되어 있다.
        - JDBC 드라이버나 DataSource 등에서 재설정 할 수 있다.
        - 필요에 따라 트랜잭션 단위로 격리수준을 조정할 수 있다.
- 제한시간(Timeout)
    - 트랜잭션을 수행하는 시간을 제한할 수 있다.
    - `DefaultTransactionDefinition`의 기본 설정은 제한시간이 없다.
    - PROPAGATION_REQUIRED나 PROPAGATION_REQUIRES_NEW와 함께 사용할 때 의미가 있다.
- 읽기 전용(Read Only)
    - 읽기 전용을 통해 데이터 조작을 막을 수 있다.
    - 데이터 액세스 기술에 따라 성능이 향상될 수도 있다.
- 트랜잭션 정의를 수정하려면 트랜잭션 결계 설정 기능을 가진 `TransactionAdvice`에서 외부로부터 `TransactionDefinition` 객체를 DI 받아서 사용하도록 하면 된다.
    - 이 방법은 `TransactionAdvicd`를 사용하는 모든 트랜잭션의 속성이 한번에 바뀐다는 문제가 있다.

### 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

- 메서드별로 다른 트랜잭션 전의를 적용하려면 어드바이스의 기능을 확장해야 한다.
- `TransactionInterceptor`
    - 스프링에서 제공하는 트랜잭션 경계설정 어드바이스
    - 메서드 이름 패턴을 이용해서 트랜잭션 정의를 다르게 지정할 수 있는 방법을 제공해준다.
    - `Properties` 타입의 프로퍼티를 통해 부가기능의 동작 방식을 제어할 수 있다.
        - 기본적인 두 가지 종류의 예외 처리 방식
            - 언체크 예외(런타임 예외)
                - 트랜잭션 롤백
            - 체크 예외
                - 비즈니스 로직에 따른 리턴 방식으로 인식하고 트랜잭션 커밋
        - `rollbackOn()` 속성을 통해 기본적인 예외 원칙과 다르게 처리할 수 있다.
- 메서드 이름 패턴을 이용한 트랜잭션 속성 지정
    - `Properties` 타입의 프로퍼티는 메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션
    - 트랜잭션 속성은 문자열로 정의할 수 있다.
        ```text
        PROPAGATION_NAME, ISOLATION_NAME, readonly, timeout_NNNN, -Exception1, +Exception2
        ```
        - `PROPAGATION_NAME`
            - 트랜잭션 전파 방식
            - 필수 항목
        - `ISOLATION_NAME`
            - 격리 수준
            - 생략되면 기본 격리 수준으로 지정된다.
        - `readonly`
            - 읽기 전용 항목
            - 기본 설정은 읽기 전용이 아니다.
        - `timeout_NNNN`
            - 제한 시간
        - `-Exception1`
            - 체크 예외 중 롤백 대상으로 추가
            - 한 개 이상 등록할 수 있다.
        - `+Exception2`
            - 런타임 예외지만 롤백시키지 않을 예외
            - 한 개 이상 등록할 수 있다.
        ```xml
        <bean id="transactionAdvice" class="org.springframework.transaction.interceptor.TransactionInterceptor">
            <property name="transactionManager" ref="transactionManager"/>
            <property name="transactionAttributes">
                <props>
                    <prop key="get*">PROPAGATION_REQUIRED, readOnly,timeout_30</prop>
                    <prop key="upgrade*">PROPAGATION_REQUIRED_NEW, ISOLATION_SERIALIZABLE</prop>
                    <prop key="*">PROPAGATION_REQUIRED</prop>
                </props>
            </property>
        </bean> 
        ```
- tx 네임스페이스를 이용한 설정 방법(소스 참고)
    - tx 스키마의 태그를 사용하는 것을 권장한다.
        - 개별 속성을 통해 지정되기 때문에 가독성이 좋다.
        - 자동완성 기능을 이용할 수 있다.
        - XML 스키마에 미리 등록해둔 값을 통해 오타를 검증할 수 있다.

### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략

- aop와 tx 스키마의 전용 태그를 사용하면 애플리케이션의 어드바이저, 어드바이스, 포인트컷 기본 설정 방법 변경 없이 트랜잭션 속성을 변경할 수 있다.
- 트랜잭션 포인트컷 표현식은 타입 패턴이나 빈 이름을 이용한다.
    - 트랜잭션 적용 대상 클래스의 모든 메서드에 트랜잭션을 적용하는 것을 권장한다.
        - 조회 메서드는 트랜잭션 속성 읽기전용 설정을 통해 성능을 향상시킬 수 있다.
        - 격리 수준에 따라 트랜잭션 내에서 실행 할 필요가 있다.
    - 트랜잭션용 포인트컷 표현식에 메서드나 파라미터, 예외에 대한 패턴을 정의하는건 바람직하지 않다.
    - 가능하면 인터페이스 타입을 기준으로 타입 패턴 적용을 권장한다.
    - 포인트컷 표현식 종류
        - `execution()`
        - `bean()`
            - 스프링 빈 이름을 기준으로 선정
            - 클래스/인터페이스 이름에 일정한 규칙을 만들기 어려운 경우 유용하다.
            - 표현식이 간결하다.
        - 어노테이션 기반 포인트컷 표현식
- 공통된 메서드 이름 규칙을 통해 최소한의 트랜잭션 어드바이스와 속성을 정의한다.
    - 다양한 트랜잭션 속성을 사용하는 경우 관리가 어렵다.
    - 기준이 되는 가지 트랜잭션 속성을 정의한다.
        ```xml
        <tx:advice id="transactionAdvice">
            <tx:attributes>
                <tx:method name="*"/>
            </tx:attributes>
        </tx:advice>
        ```
    - 그에 따라 적절한 메서드 명명 규칙을 통해 관리하는 것이 좋다.
        ```xml
        <tx:advice id="transactionAdvice">
            <tx:attributes>
                <tx:method name="*"/>
                <tx:method name="get*" read-only="true"/>
            </tx:attributes>
        </tx:advice>
        ```
        - 읽기전용 속성 설정된 메서드에서 데이터 조작이 발생하면 예외가 발생한다.
    - 예외적인 경우에는 트랜잭션 어드바이스와 포인트컷을 새롭게 추가해줄 필요가 있다.
        ```xml
        <aop:config>
            <aop:advisor advice-ref="transactionAdvice" pointcut="execution(* *..*ServiceImpl.upgrade*(..))"/>
            <aop:advisor advice-ref="batchTxAdvice" pointcut="execution(* *..*BatchJob.*(..))"/>
        </aop:config>
          
        <tx:advice id="transactionAdvice">
            <tx:attributes>
                <tx:method name="*"/>
                <tx:method name="get*" read-only="true"/>
            </tx:attributes>
        </tx:advice>
        
        <tx:advice id="batchTxAdvice">
            <tx:attributes>
                <tx:method name="*"/>
            </tx:attributes>
        </tx:advice>
        ```
- 프록시 방식 AOP는 같은 타깃 오브젝트 내의 메서드를 호출할 때는 적용되지 않는다.
    - 프록시 방식의 AOP는 클라이언트로부터 프록시를 통해 타깃을 호출할 때만 부가기능이 적용된다.
    - 타깃 객체가 자기 자신의 메서드를 호출할 때는 프록시를 거치지 않아 부가기능이 적용되지 않는다.
    - 같은 객체 안에서의 호출을 새로운 트랜잭션 속성을 부여하지 못한다는 점을 주의해야 한다.
    - 해결 방법
        - 프록시 강제 호출
            - 프록시 객체를 사용하여 내부 메서드를 호출할 때 프록시를 통해 호출하도록 실행
            - 비즈니스 로직에 스프링 API와 프록시 코드가 존재한다.
            - 권장하지 않는다.
        - AspectJ와 같이 바이트코드를 직접 조작하는 방식의 AOP 기술 적용
            - 대부분의 기존 설정은 그대로 둔 채로 간단한 옵션을 통해 AspectJ 방식으로 트랜잭션 AOP를 적용되게 할 수 있다.
            - 하지만 그만큼 다른 불편도 뒤따르기 때문에 꼭 필요한 경우만 사용해야 한다.
            - AspectJ를 통한 AOP 방법은 14장에서 알아본다.

### 6.6.4 트랜잭션 속성 적용

- 트랜잭션 경계설정의 일원화
    - 트랜잭션 경계설정의 부가기능은 특정 계층의 트랜잭션 경계와 일치시키는 것을 권장한다.
    - 비즈니스 로직을 담고 있는 서비스 계층이 적절하다.
        - 다른 계층이나 모듈에서 DAO에 직접 접근하는 것은 차단해야 한다.
        - 서비스 계층의 위임 메서드를 통해 접근해야 한다.
            - 부가 로직을 적용할 수 있다.
            - 트랜잭션 속성을 제어할 수 있다.
- 서비스 빈에 적용되는 포인트컷 표현식 등록
    ```xml
    <aop:config>
        <aop:advisor advice-ref="transactionAdvice" pointcut="bean(*Service)"/>
    </aop:config>
    ```
- 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록
  <tx:advice id="transactionAdvice">
  <tx:attributes>
  <tx:method name="get*" read-only="true"/>
  <tx:method name="*"/>
  </tx:attributes>
  </tx:advice>
    ```
- 트랜잭션 속성 테스트(소스 참고)
    - `TransientDataAccessResourceException`
        - 스프링의 `DataAccessException`의 한 종류로, 일시적인 예외상황에서 발생하는 예외다.
        - 일시적이란 재시도를 하면 성공할 가능성이 있다는 의미다.
            - 정상적으로 처리될 수 있는 상황에도 불구하고 일시적인 제약조건으로 인해 예외가 발생했다는 것을 나타낸다.

## 6.7 어노테이션 트랜잭션 속성과 포인트컷

- 포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄 적용하는 방식은 대부분의 상황에서 사용할 수 있다.
- 메서드별로 다른 트랜잭션 속성이 필요할 경우 패턴 기반 설정은 적합하지 않다.
    - 매번 포인트컷과 어드바이스를 추가해야 한다.
    - 포인트컷 자체와 설정 파일이 복자해진다.
- 이런 경우 스프링에서 제공하는 어노테이션을 지정하는 방법을 사용할 수 있다.

### 6.7.1 트랜잭션 어노테이션

- `@Transactional`
    - 메서드와 클래스, 인터페이스에 사용할 수 있다.
    - `@Transactional` 어노테이션을 트랜잭션 속성정보로 사용하도록 지정하면 스프링은 모든 객체를 자동 타깃 객체로 인식한다.
    - `TransactionAttributeSourcePointcut` 포인트컷이 사용된다.
        - `@Transactional` 어노테이션이 부여된 빈 객체를 모두 찾아서 선정 결과로 돌려준다.
    - 트랜잭션 속성 정의와 동시에 포인트컷의 자동등록에도 사용된다.
- 트랜잭션 속성을 이용하는 포인트컷
    - `TransactionInterceptor`는 `AnnotationTransactionAttributeSource`를 사용한다.
        - `AnnotationTransactionAttributeSource`는 `@Transactional` 어노테이션의 트랜잭션 속성을 가져온다.
        - 메서드마다 트랜잭션 속성을 다르게 설정할 수 있다.
- 대체 정책
    - 스프링은 `@Transactional`을 적용할 때 4단계의 대체(Fallback) 정책을 이용할 수 있다.
        - 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입(클래스, 인터페이스) 순으로 `@Transactional` 속성정보를 사용한다.
    - 적용 전략
        - 공통 속성은 먼저 타입 레벨에 정의한다.
        - 공통 속성을 따르지 않는 예외적인 메서드에 대해서만 메서드 레벨에 `@Transactional`을 부여한다.
        - 인터페이스에 `@Transactional`을 적용하는 경우
            - 구현 클래스와 상관없이 트랜잭션 속성을 유지할 수 있다.
            - 하지만 프록시 방식의 AOP에서만 유효하기 때문에 안전하게 타깃 클래스에 적용하는 것을 권장한다.
- 트랜잭션 어노테이션 사용을 위한 설정(소스 참고)

### 6.7.2 트랜잭션 어노테이션 적용

- `@Transactional` 어노테이션을 사용하면 편리하고, 가독성이 좋다.
- 단점
    - 트랜잭션 적용 대상을 일괄적으로 파악하기 어렵다.
    - 명확한 사용 정책이 없다면 무분별하게 사용되거나, 빼먹을 위험이 있다.
    - 트랜잭션 적용 여부는 파악하기 어렵다.
        - 트랜잭션이 적용되지 않아도 정상 동작하기 때문에, 예외 발생해서 롤백이 필요한 시점에서야 문제를 발견할 수 있다.

## 6.8 트랜잭션 지원 테스트

### 6.8.1 선언적 트랜잭션과 전파 속성

- 트랜잭셔을 정의할 때 트랜잭션 전파 속성은 유용한 개념이다.
    - REQUIRED 전파 속성을 가진 메서드를 결합해서 다양한 크기의 트랜잭션 작업을 만들 수 있다.
        - `UserService.add()` 메서드는 독자적인 트랜잭션 단위가 될 수 있고, 특정 작업의 트랜잭션의 일부로 참여할 수도 있다.
    - 트랜잭션 적용으로 인해 불필요한 코드 중복을 피할 수 있다.
        - 트랜잭션 전파라는 기법이 없다면, 하나의 트랜잭션으로 참여해야하는 상황에 `UserService.add()` 코드를 복사해서 사용하게 된다.
    - 애플리케이션을 작은 기능 단위로 쪼개서 개발할 수 있다.
- 선언적 트랜잭션(Declarative Transaction)
    - AOP를 이용해 코드 외부에서 트랜잭션의 기능을 부여해주고, 속성을 지정할 수 있게 하는 방법
- 프로그램에 의한 트랜잭션(Programmatic Transaction)
    - `TransactionTemplate` 같은 개별 데이터 기술의 트랜잭션 API를 사용해 직접 코드 안에서 사용하는 방법
- 스프링은 두 가지 방법 모두 지원하지만, 특별한 경우가 아니라면 선언적 트랜잭션 방식을 권장한다.

### 6.8.2 트랜잭션 동기화와 테스트

- AOP와 스프링의 트랜잭션 추상화를 통해 자유로운 전파와 유연한 개발이 가능할 수 있었다.
    - AOP 기반 프록시를 통한 트랜잭션 부가기능을 간단하게 적용할 수 있었다.
    - 스프링은 트랜잭션 추상화를 통해 데이터 액세스 기술에 상관없이, 트랜잭션 기술에 상관없이 유연한 개발을 제공한다.
- 트랜잭션 매니저와 트랜잭션 동기화
    - 트랜잭션 추상화의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
        - `PlatformTransactionManager` 인터페이스를 통해 트랜잭션 기술의 종류와 상관없이 일관된 트랜잭션 제어가 가능하다.
        - 트랜잭션 동기화 기술을 통해 DAO에서 트랜잭션 정보를 공유할 수 있다.
        - 트랜잭션 동기화 기술 덕에 진행중인 트랜잭션을 확인하고, 전파 속성에 따라 참여할 수 있도록 만들 수 있다.
    - 필요에 따라 트랜잭션 매니저를 이용해 트랜잭션에 참여할 수 있다.
- 트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어
- 트랜잭션 동기화 검증
    - 선언적 트랜잭션 뿐만 아니라 `JdbcTemplate`과 같이 스프링이 제공하는 데이터 액세스 추상화를 적용한 DAO에도 영향을 미친다.
    ```java
    @Test
    void transactionSync() {
        assertThrows(TransientDataAccessResourceException.class, () -> {
            DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
            transactionDefinition.setReadOnly(true);

            TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);

            userService.deleteAll();

            userService.add(users.get(0));
            userService.add(users.get(1));

            transactionManager.commit(transactionStatus);
        });
    }
    ```
- 롤백 테스트
    - 롤백 테스트는 테스트 성공/실패와 상관없이 테스트 하는 동안 조작한 데이터를 모두 롤백하고 테스트 시작 전 상태로 만들어주기 때문에 매우 유용하다.
    - 공통으로 사용하는 정보는 전체 테스트 수행 전 DB에 넣어두면 된다.
    - 적절한 격리수준만 보장해주면 동시에 여러 개의 테스트가 진행돼도 상관없다.
    - 일반적으로 롤백이 커밋보다 성능이 좋지만, 트랜잭션 처리 방법에 따라 롤백이 더 많은 부하를 주는 경우도 있기 때문에 단지 성능 때문에 롤백 테스트가 낫다고 볼 수 없다.

### 6.8.3 테스트를 위한 트랜잭션 어노테이션

- `@Transactional` 어노테이션은 클래스 또는 인터페이스에 부여하는 것만으로 트랜잭션을 적용해주는 편리한 기술이다.
- 뿐만 아니라 테스트 클래스와 메서드에도 적용할 수 있다.
- 스프링의 컨텍스트 테스트 프레임워크는 어노테이션을 이용한 테스트를 편리하게 만들 수 있는 여러 가지 기능을 추가하게 해준다.
    - `@ContextConfiguration`을 클래스에 부여하면 테스트 실행 전 스프링 컨테이너를 초기화한다.
    - `@Autowired` 어노테이션이 적용된 필드를 통해 테스트에 필요한 빈에 자유롭게 접근할 수 있다.
- `@Transactional`
    - 테스트 클래스 또는 메서드에 `@Transactional` 어노테이션을 부여해주면 트랜잭션 경계가 자동으로 설정된다.
    - 이를 통해 테스트 내에서 진행하는 모든 트랜잭션 관련 작업을 하나로 묶어줄 수 있다.
    - AOP를 위한 것이 아닌 컨텍스트 테스트 프레임워크에 의해 트랜잭션을 부요혀주는 용도로 사용된다.
- `@Rollback`
    - 테스트에 적용된 `@Transactional`은 기본적으로 트랜잭션을 가제 롤백시키도록 설정되어 있다.
    - `@Rollback` 어노테이션을 사용하면 테스트에서 진행한 작업을 DB에 반영할 수 있다.
    - `@Transactional`은 테스트를 목적이 아니기 떄문에 롤백 테스트 관련 설정을 할 수 없기 때문에 별도의 어노테이션을 사용한다.
    - 트랜잭션은 적용되지만 롤백을 원하지 않는다면 `@Rollback(false)`로 설정해야 한다.
- `@TransactionConfiguration`
    - 테스트 클래스의 모든 메서드에 트랜잭션 공통 속성을 적용할 때 사용하면 편리하다.
- NotTransactional과 Propagation.NEVER
    - 일부 메서드에만 트랜잭션이 필요하다면 메서드 레벨의 `@Transactional`을 적용하고, 대부분의 메서드에서 트랜잭션이 필요하다면 클래스에 `@Transactiol`을 지정하면 편리하다.
    - 테스트 메서드에 `@NotTransactional`을 부여하면 `@Transactional` 설정을 무시한다.
        - 스프링 3.0에서 Deprecated ehoTek.
    - 트랜잭션 전파 속성을 Propagation.NEVER로 지정하면 트랜잭션이 시작되지 않는다.
- 효과적인 DB 테스트
    - 고립된 상태에서 테스트를 진행하는 단위 테스트와 여러 계층이 참여하는 통합 테스트는 클래스를 구분해서 따로 만드는게 좋다.
        - 통합테스트를 별도의 클래스로 만든다면 기본적으로 클래스 레벨에 `@Transactional`을 부여해준다.
            - 통합테스트를 롤백 테스트로 만들면 공통으로 이용할 수 있는 테스트 DB를 셋업해주고, 각 테스트는 자신이 필요한 테스트 데이터를 보충해서 진행하게 만들 수 있다.
            - 기본적으로 롤백 테스트는 독립적이고 자동화된 테스트로 만들기 편리하다.
        - 테스트는 어떤 경우에도 서로 의존하면 안된다.
        - 트랜잭션을 지원한느 롤백 테스트는 유용한 도구가 될 것이다.

## 6.9 정리

- 트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일한 인터페이스를 구현하면 DI의 확장 기능을 이용해 클라이언트의 변경 없이도 깔끔하게 분리된 트랜잭션 부가기능을 만들 수 있다.
- 트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다.
- 목 객체를 활용하면 의존관계 속에 있는 객체도 손쉽게 고립된 테스트로 만들 수 있다.
- DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
- 번거로운 프록시 클래스 작성은 JDK의 다이나믹 프록시를 사용하면 간단하게 만들 수 있다.
- 다이나믹 프록시는 스태틱 팩토리 메서드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다. 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.
- 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 활용할 수 있다. 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
- 포인트컷은 AspectJ 포인트컷 표현식을 사용해서 작성하면 편리하다.
- AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.
- 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는 데 사용할 수 있는 전용 태그를 제공한다.
- AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메서드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 `Transactional` 어노테이션을 사용하는 방법이 있다.
- `@Transactional`을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.
