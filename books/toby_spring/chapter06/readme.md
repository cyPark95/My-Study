# 6장 AOP

- AOP(Aspect-Oriented Programming)는 IoC/DI, 서비스 추상화와 함께 스프링의 3대 핵심 기반 기술 중 하나
- AOP는 용어와 개념이 다소 어려워 충분한 이해가 뒷받침될 때 효과적으로 활용할 수 있다.
- 스프링에서 대표적으로 AOP가 적용된 사례는 선언적 트랜잭션 관리이다.

## 6.1 트랜잭션 코드의 분리

- `UserService`는 트랜잭션 기술에 독립적이고, 메일 발송 기술과 환경에 종속되지 않도록 다듬어 왔다.
- 하지만 트랜잭션 경계 설정을 위한 코드가 존재한다.

### 6.1.1 메서드 분리

- 비즈니스 로직과 트랜잭션을 담당하는 두 가지 종류의 코드가 구분되어 있다.
- 두 코드 간에 주고받는 정보가 없다.
- 메서드 추출을 통해 독립시킬 수 있다.(소스 참고)

### 6.1.2 DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService`에 존재한다.
- DI 적용을 이용한 트랜잭션 분리
    - 현재 `UserService` 클래스와 클라이언트 간의 관계가 강한 결합도로 고정되어 있다.
        - 트랜잭션 코드를 `UserService` 밖으로 빼버리면 클라이언트는 트랜잭션 기능이 빠진 `UserService`를 사용하게 된다.
    - 인터페이스와 DI를 적용하면 클라이언트와 결합이 약해지고, 유연한 확장이 가능해진다.
- `UserService` 인터페이스 도입(소스 참고)
- 분리된 트랜잭션 기능(소스 참고)
- 트랜잭션 적용을 위한 DI 설정(소스 참고)
- 트랜잭션 분리에 따른 테스트 수정(소스 참고)
    - `@Autowired`는 기본적으로 타입이 일치하는 빈을 찾아준다.
- 트랜잭션 경계설정 코드 분리의 장점
    - 비즈니스 로직을 담당하고 있는 `UserServiceImpl`는 트랜잭션과 같은 기술적인 내용은 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 작은 단위로 쪼개서 테스트하는 것이다.
    - 테스트가 실패했을 때 원인을 찾기 쉽다.
    - 테스트의 의도나 내용이 분명해진다.
    - 테스트를 작성하기 쉽다.

### 6.2.1 복잡한 의존관계 속의 테스트

- 현재 `UserService`는 세 가지 의존 객체가 필요하다.
    - `UserDao`
    - `MailSender`
    - `PlatformTransactionManager`
- 세 가지 의존 객체들은 테스트가 진행되는 동안 JDBC, 네트워크, 메일 서버 등 함께 테스트 된다.
    - 테스트를 준비하기 힘들다.
    - 환경이 달라지면 동일한 테스트 결과를 받지 못할 수 있다.
    - 테스트 수행 속도가 느리다.

### 6.2.2 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 종속되고 영향 받지 않도록 고립시킬 필요가 있다.
- 테스트를 위한 `UserServiceImpl` 고립
    - `UserDao`는 테스트 결과를 검증하기 위한 목 객체로 작성한다.
- 고립된 단위 테스트 활용
    - `UserDao`를 통해 테스트에 필요한 정보를 DB에 넣기위해 준비한다.
    - `MailSender` 목 객체 DI를 통해 의존 객체와 서버 등에서 고립시킨다.
- `UserDao` 목 객체(소스 참고)
    - 사용하지 않는 메서드는 실수로 사용되지 않도록 `UnsupportedOperationException` 예외가 발생하도록 만드는 것을 권장한다.
- 테스트 수행 성능의 향상
    - 의존 대상으로부터 고립된 테스트를 통해 수행 속도가 빨라졌다.

### 6.2.3 단위 테스트와 통합 테스트

- 단위 테스트의 단위는 정하기 나름이지만, 중요한 것은 하나의 단위에 초점을 맞춘 테스트라는 점이다.
- 단위 테스트
    - 테스트 대역을 통해 의존 객체나 외부 리소스를 사용하지 않는 고립된 테스트
- 통합 테스트
    - 두 개 이상의 성격이나 계층이 다른 객체가 연동하고록 만들거나 외부 리소스가 참여하는 테스트
- 단위 테스트와 통합 테스트를 결정하는 가이드라인
    - 항상 단위 테스트를 먼저 고려한다.
    - 단위 테스트는 외부 의존성을 차단하고, 빠르고 효과적으로 작성할 수 있다.
    - 외부 리소스가 필요한 테스트는 통합 테스트로 작성한다.
    - DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하는 DAO는 고립된 테스트 작성이 어렵고, 가치가 없기 때문에 DB까지 연동하는 테스트로 만드는 편이 효과적이다.
    - DAO와 같이 DB 연동이 필수인 코드는 통합 테스트로 분류한다.
    - DAO를 충분히 검증해두면, DAO를 이용하는 코드는 스텁이나 목 객체로 대체해 테스트할 수 있다.
    - 여러 개의 단위가 의존관계를 가지고 동작할 때를 위한 통합 테스트는 필요하다.
    - 충분한 단위 테스트를 거친다면 통합 테스트의 부담은 상대적으로 줄어든다.
    - 단위 테스트가 너무 복잡하면 처음부터 통합 테스트를 고려해야 하지만, 가능한 많은 부분을 미리 단위 테스트로 검증하는 것이 유리하다.
    - 스프링 테스트 컨텍스트 프레임워크를 사용하는 테스트는 통합 테스트에 해당한다.
    - 가능하다면 스프링 없이 코드 레벨에서 단위 테스트를 작성하고, 스프링 설정이나 추상적 레벨의 테스트가 필요할 경우 스프링 테스트 컨텍스트 프레임워크를 이용한 통합 테스트를 작성한다.
- 스프링이 권장하는 유연한 코드를 만들다보면 테스트도 만들기 쉬워지고, 테스트는 리팩토링과 개선을 통해 코드의 품질을 높여준다.

### 6.2.4 목 프레임워크

- 단위 테스트에서 목 객체를 만드는일은 번거롭다.
- 목 객체를 편리하게 작성하도록 도와주는 다양한 목 객체 지원 프레임워크가 있다.
- Mockito 프레임워크
    - 목 클래스를 일일히 준비해둘 필요가 없다는 특징을 가지고 있다.
    - `org.mockito.Matchers` 클래스에 정의된 스태틱 메소드를 제공한다.
    - Mockito를 이용한 테스트 코드(소스 참고)

## 6.3 다이나믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

- 트랜잭션 경계설정 코드 분리
    - 트랜잭션을 적용하는 부가기능을 핵심기능이 담긴 클래스에서 독립 시켰다.
    - 부가기능 코드에서는 핵심기능으로 요청을 위힘해주는 과정에서 부가적인 기능을 적용해줄 수 있다.
    - 클라이언트는 인터페이스로 접근하기 때문에 핵심기능을 가진 클래스를 기대하고 사용한다.
    - 프록시(Proxy): 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 대리자, 대리인과 같은 역할
    - 타깃(Target) 또는 실체(Real Subject): 프록시를 통해 요청을 위임받아 처리하는 실제 객체
    - 프록시의 목적
        - 클라이언트가 타깃에 접근하는 방법을 제어한다.
        - 타깃에 부가적인 기능을 부여해 준다.
- 데코레이터 패턴
    - 타깃에 부가적인 기능을 런타임 시 다이나믹하게 부여해주기 위해 프록시를 사용하는 패턴
        - 다이나믹하게 기능을 부가한다는 의미는 컴파일 시점에는 어떤 방법과 순서로 프록시와 타깃이 정해져 있지 않는 것을 뜻한다.
    - 데코레이터 패턴에서는 여러 개의 프록시를 사용할 수 있다.
    - 프록시로 동작하는 각 데코테이터는 위임하는 대상에 인터페이스로 접근한다.
        - 위임 대상이 최종 타깃인지 다음 데코레이터 프록시인지 알 수 없다.
        - `UserServiceTx`는 데코레이터, `UserServiceImple`은 타깃이 된다.
    - 데코레이터 패턴은 타깃의 코드와 클라이언트사 호출 방법을 변경하지 않고 새로운 기능을 추가할 때 유용한 방법이다. 
