# 6장 AOP

- AOP(Aspect-Oriented Programming)는 IoC/DI, 서비스 추상화와 함께 스프링의 3대 핵심 기반 기술 중 하나다.
- AOP는 개념과 용어가 다소 어렵기 때문에, 충분히 이해한 후에 활용해야 효과적이다.
- 스프링에서 AOP가 대표적으로 사용되는 예는 선언적 트랜잭션 관리이다.

## 6.1 트랜잭션 코드의 분리

- `UserService`는 트랜잭션 기술에 독립적이고, 메일 발송 기술과 환경에 종속되지 않도록 다듬어 왔다.
- 하지만 트랜잭션 경계 설정을 위한 코드가 존재한다.

### 6.1.1 메서드 분리

- 비즈니스 로직과 트랜잭션 처리를 담당하는 두 종류의 코드가 분리되어 있다.
- 두 코드 간에 주고받는 정보는 없다.
- 메서드 추출을 통해 독립적으로 분리할 수 있다.(소스 참고)

### 6.1.2 DI를 이용한 클래스의 분리

- 여전히 트랜잭션을 담당하는 기술적 코드가 `UserService`에 존재한다.
- DI 적용을 이용한 트랜잭션 분리
    - 현재 `UserService` 클래스는 클라이언트와 강하게 결합되어 있다.
        - 트랜잭션 코드를 `UserService` 외부로 분리하면, 클라이언트는 트랜잭션이 기능이 없는 `UserService`를 사용하게 된다.
    - 인터페이스와 DI를 적용하면, 클라이언트와의 결합도가 낮아져 유연한 확장이 가능해진다.
- `UserService` 인터페이스 도입 (소스 코드 참고)
- 분리된 트랜잭션 기능 구현 (소스 코드 참고)
- 트랜잭션 적용을 위한 DI 설정 (소스 코드 참고)
- 트랜잭션 분리에 따른 테스트 수정 (소스 코드 참고)
    - `@Autowired`는 기본적으로 타입이 일치하는 빈을 자동 주입해준다.
- 트랜잭션 경계 설정 코드 분리의 장점
    - 비즈니스 로직을 담당하는 `UserServiceImpl`은 트랜잭션과 같은 기술적인 내용은 신경쓰지 않아도 된다.
    - 비즈니스 로직에 대한 테스트를 쉽게 만들 수 있다.

## 6.2 고립된 단위 테스트

- 가장 편하고 좋은 테스트 방법은 작은 단위로 쪼개서 테스트하는 것이다.
    - 테스트가 실패했을 때 원인을 찾기 쉽다.
    - 테스트의 의도나 내용이 분명해진다.
    - 테스트를 작성하기 쉽다.

- 가장 효과적인 테스트 방법은 가능한 작은 단위로 쪼개서 테스트하는 것이다.
    - 테스트 실패 시 원인을 쉽게 파악할 수 있다.
    - 테스트의 의도와 내용이 명확해진다.
    - 테스트 작성이 간단해진다.

### 6.2.1 복잡한 의존관계 속의 테스트

- 현재 `UserService`는 세 가지 의존 객체가 필요하다.
    - `UserDao`
    - `MailSender`
    - `PlatformTransactionManager`
- 세 가지 의존 객체들은 테스트가 진행되는 동안 JDBC, 네트워크, 메일 서버 등 함께 테스트 된다.
    - 테스트를 준비가 어렵다.
    - 환경에 따라 테스트 결과가 달라질 수 있다.
    - 테스트 수행 속도가 느리다.

### 6.2.2 테스트 대상 오브젝트 고립시키기

- 테스트 대상이 환경이나, 외부 서버, 다른 클래스의 코드에 영향을 받지 않도록 고립시킬 필요가 있다.
- 테스트를 위한 `UserServiceImpl` 고립
    - `UserDao`는 테스트 결과를 검증하기 위해 목(Mock) 객체로 작성한다.
- 고립된 단위 테스트 활용
    - `UserDao`를 통해 테스트에 필요한 정보를 DB에 넣기위해 준비한다.
    - `MailSender` 목 객체 DI를 통해 의존 객체와 서버 등에서 고립시킨다.
- `UserDao` 목 객체(소스 참고)
    - 사용하지 않는 메서드는 실수로 사용되지 않도록 `UnsupportedOperationException` 예외가 발생하도록 구현하는 것을 권장한다.
- 테스트 수행 성능의 향상
    - 의존 대상으로부터 고립된 테스트를 통해 수행 속도가 빨라진다.

### 6.2.3 단위 테스트와 통합 테스트

- 단위 테스트의 단위는 정하기 나름이지만, 중요한 것은 하나의 책임이나 기능에 초점을 맞춘 테스트라는 점이다.
- 단위 테스트
    - 테스트 대역을 통해 의존 객체나 외부 리소스를 사용하지 않는 고립된 테스트
- 통합 테스트
    - 서로 다른 계층이나 성격을 가진 두 개 이상의 객체가 연동되거나, 외부 리소스가 함께 참여하는 테스트
- 단위 테스트와 통합 테스트를 결정하는 가이드라인
    - 가능하면 항상 단위 테스트를 먼저 고려한다.
    - 단위 테스트는 외부 의존성을 제거하여 빠르고, 효과적으로 작성할 수 있다.
    - 외부 리소스가 필요한 경우에는 통합 테스트로 작성한다.
    - DB를 통해 로직을 수행하는 인터페이스와 같은 역할을 하는 DAO는 고립된 테스트가 어렵고, 가치가 없기 때문에 DB 연동이 포함된 통합 테스트가 더 효과적이다.
    - DAO를 충분히 검증해두면, DAO를 이용하는 계층은 스텁이나 목 객체로 대체하여 단위 테스트를 작성할 수 있다.
    - 여러 개의 단위가 의존관계를 가지고 동작하는 경우, 통합 테스트를 통해 전체 흐름을 확인할 필요가 있다.
    - 충분한 단위 테스트가 작성되어 있다면, 통합 테스트의 부담은 줄어든다.
    - 단위 테스트가 너무 복잡하면 처음부터 통합 테스트를 고려해 볼 수 있다. 하지만 가능한 많은 부분을 미리 단위 테스트로 검증하는 것이 유리하다.
    - 스프링 테스트 컨텍스트 프레임워크를 사용하는 테스트는 통합 테스트에 해당한다.
    - 가능하다면 스프링 없이 코드 레벨에서 단위 테스트를 작성하고, 스프링 설정이나 추상적 레벨의 테스트가 필요할 경우에만 스프링 테스트 컨텍스트 프레임워크를 활용한 통합 테스트를 작성한다.
- 스프링이 권장하는 유연한 코드를 따르다 보면, 테스트 작성도 쉬워진다.
- 테스트는 리팩토링과 개선을 가능하게 하고, 결과적으로 코드의 품질을 높이는 핵심 도구가 된다.

### 6.2.4 목 프레임워크

- 단위 테스트에서 목 객체를 직접 만드는 작업은 번거롭다.
- 목 객체 생성을 편리하게 작성할 수 있도록 지원하는 다양한 프레임워크들이 존재한다.
- Mockito 프레임워크
    - 목 클래스를 직접 구현하지 않아도 된다는 장점이 있다.
    - `org.mockito.Matchers` 클래스에 정의된 정적 메서드를 활용해 다양한 조건의 매칭이 가능하다.
    - Mockito를 이용한 테스트 코드(소스 참고)

## 6.3 다이나믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

- 트랜잭션 경계설정 코드 분리
    - 트랜잭션과 같은 부가기능을, 핵심 기능이 담긴 클래스에서 분리시켰다.
    - 부가기능은 핵심 기능을 호출하기 전에 부가적인 작업을 수행하거나, 호출 이후 결과를 처리하는 방식으로 적용할 수 있다.
    - 클라이언트는 인터페이스를 통해 접근하기 때문에 핵심 기능이 구현된 클래스를 기대하고 사용한다.
    - 프록시(Proxy)
        - 실제 객체처럼 동작하면서 클라이언트의 요청을 대신 받아 처리하는 대리자, 대리인과 같은 역할
        - 타깃(Target) 또는 실체(Real Subject)
            - 프록시를 통해 요청을 위임받아 처리하는 실제 객체
        - 목적
            - 타깃에 접근 방식을 제어한다.
            - 타깃에 부가기능을 동적으로 추가할 수 있다.
- 데코레이터 패턴
    - 프록시를 이용해 런타임에 부가기능을 다이나믹하게 추가할 수 있게 해주는 디자인 패턴
        - `다이나믹하게`란, 컴파일 시점에는 프록시와 타깃이 어떤 조합으로 연결될지 결정되어 있지 않다는 의미다.
    - 데코레이터는 하나 이상의 프록시 객체로 구성될 수 있고, 프록시 체인을 통해 기능을 확장할 수 있다.
        - 프록시로 동작하는 데코레이터는 위임 대상에 인터페이스를 통해 요청을 전달한다.
            - 위임 대상이 최종 타깃인지 다음 데코레이터 프록시인지 알 수 없다.
            - `UserServiceTx`는 데코레이터, `UserServiceImple`은 타깃이 된다.
    - 데코레이터 패턴은 클라이언트 코드나 타깃 코드 변경 없이, 새로운 기능을 추가할 수 있어 유용하다.
- 프록시 패턴
    - 프록시 패턴은 일반적으로 클라이언트와 실제 객체 사이에 대리 역할을 맡는 객체를 두어 요청을 중개하는 방식을 말한다.
    - 프록시 패턴은 타깃 객체에 대한 접근을 제어하거나 제한하려는 목적을 가진 경우를 가르킨다.
    - 프록시 패턴은 타깃의 기능 자체에는 관여하지 않고, 접근 방식만 제어하는 프록시를 이용하는 방법이다.

### 6.3.2 다이나믹 프록시

- 프록시 패턴은 기존 코드에 영향을 주지 않으면서 타깃 객체의 기능을 확장하거나 접근 방식을 제어할 수 있는 유용한 방법이다.
- 하지만 매번 새로운 프록시 클래스를 정의해야 하고, 인터페이스의 모든 메서드를 구현해야 하는 번거로움이 있다.
- 프록시의 구성과 프록시 작성의 문제점
    - 프록시의 역할
        - 타깃과 동일한 인터페이스를 구현한다.
        - 메서드가 호출되면 타깃 객체에 요청을 위임한다.
        - 필요한 경우, 특정 메서드 호출 전후에 부가기능을 수행한다.
    - 프록시 작성할 때의 문제점
        - 타깃 인터페이스의 모든 메서드를 구현하고, 각 메서드에서 타깃으로 위임하는 코드를 작성해야 한다.
        - 부가기능이 필요 없는 메서드까지 모두 구현해야 한다.
        - 동일한 부가기능 코드가 여러 메서드에 중복될 가능성이 있다.
- 리플렉션
    - 리플렉션은 자바의 코드 자체를 추상화해서 접근할 수 있도록 해주는 기능이다.
    - 다이나믹 프록시는 리플렉션 기능을 이용해 프록시 객체를 런타임에 자동으로 생성한다.
    - 리플렉션 학습 테스트(소스 참고)
- 프록시 클래스(소스 참고)
- 다이나믹 프록시 적용(소스 참고)
    - 다이나믹 프록시는 프록시 팩토리에 의해 런타임 시 자동 생성된다.
    - 클라이언트의 모든 메서드 호출은 리플렉션 정보로 변환해서 `InvocationHandler` 인터페이스의 `invoke()` 메서드로 전달된다.
        - 인터페이스의 모든 메서드 호출이 하나의 메서드로 집중되기 때문에 공통된 부가기능을 일관되게 처리할 수 있다.
        - 메서드 이름, 파라미터 등 호출 정보 전체를 전달받아 리플렉션을 통해 타깃 객체의 메서드를 실행할 수 있다.
    - 다이나믹 프록시는 `Proxy.newProxyInstance()` 정적 팩토리 메서드를 통해 생성된다.(소스 참고)
- 다이나믹 프록시의 확장(소스 참고)
    - `Hello` 인터페이스의 메서드가 30개로 늘어날 경우
        - 직접 구현한 프록시는 모든 메서드를 추가로 구현해야 하므로 매우 번거롭다.
        - 하지만 다이나믹 프록시는 메서드가 추가되어도 자동으로 처리 가능하며, 부가기능은 `invoke()` 메서드 내에서 일관되게 다룰 수 있다.

### 6.3.3 다이나믹 프록시를 이용한 트랜잭션 부가기능

- `UserServiceTx` 방식의 한계를 해결하기 위해, 트랜잭션 부가기능을 다이나믹 프록시 방식으로 변경한다.
    - 인터페이스의 모든 메서드를 구현해야 한다.
    - 트랜잭션이 필요한 메서드마다 중복되는 트랜잭션 처리 코드가 반복된다.
- 트랜잭션 `InvocationHandler`(소스 참고)
- `TransactionHandler`와 다이나믹 프록시를 이용하는 테스트
    ```java
    @Test
    void upgradeAllOrNothing() throws Exception {
        // ...

        TransactionHandler txHandler = new TransactionHandler();
        txHandler.setTarget(testUserService);
        txHandler.setTransactionManager(transactionManager);
        txHandler.setPattern("upgradeLevels");
        UserService txUserService = (UserService) Proxy.newProxyInstance(
                getClass().getClassLoader(),
                new Class[]{UserService.class},
                txHandler
        );

        // ...
    }
    ```

### 6.3.4 다이나믹 프록시를 위한 팩토리 빈

- 다이나믹 프록시 객체를 스프링 빈으로 등록할 방법이 없다.
    - 스프링은 지정된 클래스의 이름을 기반으로 `Class.newInstance()` 메서드를 사용해 기본 생성자를 호출하는 방식이다.
- 팩토리 빈
    - 스프링은 클래스 정보를 가지고 빈을 만들 수 있는 여러 가지 방법을 제공한다.
    - 대표적으로 팩토리 빈을 이용한 방법이 있다.
        - 팩토리 빈은 스프링을 대신해서 객체의 생성 로직을 담당하도록 만들어진 특별한 빈이다.
        - 팩토리 빈을 만드는 간단한 방법은 스프링의 `FactoryBean` 인터페이스를 구현하는 것이다.
        - 팩토리 빈을 사용하면 다이나믹 프록시를 스프링 빈으로 등록할 수 있다.
- 팩토리 빈의 설정
    ```xml
    <bean id="userService" class="study.user.service.TxProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="transactionManager" ref="transactionManager"/>
        <property name="pattern" value="upgradeLevels"/>
        <property name="serviceInterface" value="study.user.service.UserService"/>
    </bean>
    ```
- 다이나믹 프록시를 만들어주는 팩토리 빈
    - 팩토리 빈의 `getObject()` 메서드에 다이나믹 프록시를 생성하는 로직을 구현하면 스프링 빈으로 만들 수 있다.
- 트랜잭션 프록시 팩토리 빈(소스 참고)
- 트랜잭션 프록시 팩토리 빈 테스트(소스 참고)

### 6.3.5 프록시 팩토리 빈 방식의 장점과 한계

- 프록시 팩토리 빈의 재사용
    - 타깃 객체에 맞은 프로퍼티 정보를 설정해서 빈으로 등록해주면, 다양한 클래스에 적용할 수 있다.
- 프록시 팩토리 빈 방식의 장점
    - 프록시 클래스를 직접 구현하지 않아도 된다.
        - 인터페이스를 구현한 프록시 클래스를 매번 작성하는 번거로움을 제거할 수 있다.
    - 부가기능을 단일 메서드로 집중 처리할 수 있다.
        - `InvocationHandler`의 `invoke()` 메서드 한 곳에 부가기능 로직을 작성하면, 다양한 메서드에 일괄 적용할 수 있다.
    - 다이나믹 프록시 생성 코드를 제거할 수 있다.
        - 프록시 팩토리 빈을 이용해 스프링 설정에서 DI를 통해 프록시 생성 코드를 제거할 수 있다.
- 프록시 팩토리 빈의 한계
    - 여러 클래스에 동시에 공통 부가기능을 제공할 수 없다.
        - 각 클래스마다 별도의 프록시 빈 설정이 필요하다.
    - 하나의 타깃에 여러 부가기능을 적용하기 어렵다.
        - 프록시 체인을 구성하거나 중첩해서 부가기능을 적용하려면 설정이 복잡해지고 가독성이 떨어질 수 있다.
    - `TransactionHandler` 객체가 프록시 빈 개수만큼 생성된다.

## 6.4 스프링의 프록시 팩토리 빈

### 6.4.1 `ProxyFactoryBean`

- 스프링은 다양한 프록시 기술에 서비스 추상화를 적용해 일관된 방식으로 프록시를 만들 수 있도록 지원한다.
- 생성된 프록시는 스프링의 빈으로 등록되어야 한다.
- `ProxyFactoryBean`
    - 스프링이 제공하는 프록시를 생성하기 위한 팩토리 빈이다.
    - 순수하게 프록시를 생성하는 작업만 담당하고, 부가기능은 별도의 빈으로 분리해 관리할 수 있다.
- `MethodInterceptor`
    - 프록시에 적용할 부가기능은 MethodInterceptor 인터페이스를 구현한 클래스로 정의한다.
    - `InvocationHandler`와 유사하지만, 다음과 같은 장점이 있다.
        - 타깃 객체에 대한 정보도 함께 제공받을 수 있다.
        - 싱글톤 빈으로 등록 가능하다.
        - 여러 타깃 프록시에 재사용 가능하다.
    - 프록시 내에서 부가기능만 담당하며, 타깃 메서드를 호출하기 위해 `MethodInvocation.proceed()`를 사용한다.
        - 템플릿-콜백 패턴에 해당한다.
            - 템플릿: `MethodInterceptor`
            - 콜백: `MethodInvocation`
- 어드바이스(소스 참고)
    - 스프링에서 `MethodInterceptor`는 부가기능을 담은 객체를 어드바이스(Advice)라고 한다.
    - `ProxyFactoryBean.addAdvice()` 메서드를 통해 하나 이상의 어드바이스를 프록시에 추가할 수 있다.
    - 스프링의 `ProxyFactoryBean`은 인터페이스 자동검출 기능을 사용해 타깃 객체가 구현하고 있는 인터페이스를 동일하게 구현하는 프록시를 만들어 준다.
- 포인트컷
    - 부가기능 적용 대상 메서드를 선정하는 기준을 포인트컷(Pointcut)이라고 한다.
    - `TxProxyFactoryBean`의 `pattern`과 같이 `Methodlnterceptor`는 부가기능을 제공할 메서드 선정 기능을 넣을 수 없다.
        - 여러 프록시가 공유해서 사용하기 위해 타깃 정보를 갖지 않도록 만들었다.
        - `Methodlnterceptor`는 스프링의 싱글톤 빈으로 등록되어 여러 프록시에서 재사용될 수 있다.
    - 스프링의 `ProxyFactoryBean` 동작 흐름
        - 클라이언트로부터 요청을 받은 프록시는 포인트컷을 통해 부가기능을 부여한 메서드인지 확인한다.
        - 적용 대상이라면 `MethodInterceptor` 타입의 어드바이스를 호출한다.
        - 실제 타깃 객체의 레퍼런스를 가지고, 메서드를 직접 호출하는 것은 `Invocation` 콜백의 역할이다.
    - 설계상의 이점
        - 전략 패턴
            - 프록시로부터 어드바이스와 포인트컷을 독립시키고 DI를 사용하는 구조다.
        - OCP
            - 부가기능 방식이나 메서드 선정 알고리즘을 변경하더라도 기존 코드는 변경하지 않고 설정만 수정하면 된다.
    - 포인트 컷을 적용한 테스트 작성
        - `ProxyFactoryBean`은 여러 개의 어드바이스와 포인트컷이 추가할 수 있도록 포인트컷을 별개의 객체로 묶어서 등록한다.
            - 어떤 어드바이스(부가기능)에 어떤 포인트컷(메서드 선정)을 적용해야할지 애매하기 때문에 `Advisor` 타입의 객체에 담아서 등록해야 한다.
        - 어드바이스와 포인트컷을 묶은 객체를 어드바이저라고 한다.
            - 어드바이저 = 포인트컷(메서드 선정 알고리즘) + 어드바이스(부가기능)

### 6.4.2 `ProxyFactoryBean` 적용

- `TransactionAdvicd`(소스 참고)
- 스프링 XML 설정 파일(소스 참고)
    ```xml
    <bean id="transactionAdvice" class="study.user.service.TransactionAdvice">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="transactionPointcut" class="study.user.service.NameMatchClassMethodPointcut">
        <property name="mappedClassName" value="*ServiceImpl"/>
        <property name="mappedName" value="upgrade*"/>
    </bean>

    <bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
        <property name="advice" ref="transactionAdvice"/>
        <property name="pointcut" ref="transactionPointcut"/>
    </bean>

    <bean id="userService" class="org.springframework.aop.framework.ProxyFactoryBean">
        <property name="target" ref="userServiceImpl"/>
        <property name="interceptorNames">
            <list>
                <value>transactionAdvisor</value>
            </list>
        </property>
    </bean>
    ```
- 테스트(소스 참고)
- 어드바이스와 포인트컷의 재사용
    - `ProxyFactoryBean`은 스프링의 DI와 템플릿/콜백 패턴, 서비스 추상화 등의 기법이 모두 적용된 것이다.
    - 어드바이스와 포인트컷을 독립적인 객체로 분리하여 여러 프록시가 공유할 수 있다.
    - 트랜잭션 부가기능(`TransactionAdvice`)을 다양한 서비스 클래스에서 재사용할 수 있다.

## 6.5 스프링 AOP

- 지금까지 트랜잭션 코드를 효과적으로 분리했고, 분리해낸 트랜잭션 코드는 기존 설계와 코드에는 영향을 주지 않는다.
    - 이런 성질을 투명성(Transparency)이라고 한다.
    - 개발자는 부가기능이 적용되었는지 의식하지 않고도 비즈니스 로직을 작성할 수 있다.

### 6.5.1 자동 프록시 생성

- 문제점: `ProxyFactoryBean` 설정정보의 반복
    - 필요한 타깃 객체마다 비슷한 내용의 `ProxyFactoryBean` 설정정보를 추가해야한다.
        - 설정의 중복과 관리의 어려움이 생긴다.
- 중복 문제의 접근 방법
    - JDBC try/catch/finally 블록으로 구성된 코드는 전략 패턴과 DI를 적용해서 해결했다.
    - 반복적인 위임 코드가 필요한 프록시 클래스는 런타임 코드 자동생성 기법인 다이나믹 프록시를 통해 해결했다.
    - 하지만 한 번에 여러 개의 빈에 프록시를 일괄 적용할 방법은 없다.
- 빈 후처리기를 이용한 자동 프록시 생성기
    - 스프링은 컨테이너로서 제공하는 기능 중 핵심적인 부분 외에는 확장할 수 있도록 확장 포인트를 제공한다.
    - 그 중 빈 후처리기(BeanPostProcessor)는 스프링 빈 객체가 만들어지고 난 후에, 빈 객체를 가공할 수 있게 해준다.
    - `DefaultAdvisorAutoProxyCreator`는 어드바이저를 이용한 자동 프록시 생성 빈 후처리기다.
        - 스프링이 생성하는 빈 객체의 일부를 프록시로 포장하고, 프록시를 빈으로 대신 등록할 수 있다.
    - 자동 프록시 생성 방법
        1. 스프링은 빈 객체를 생성한다.
        2. 생성된 빈은 `DefaultAdvisorAutoProxyCreator` 빈 후처리기에 전달한다.
        3. 등록된 어드바이저의 포인트컷을 이용해, 프록시 적용 대상인지 확인한다.
        4. 적용 대상이면
            - 내장된 프록시 생성기에 현재 빈에 대한 프록시를 만들게 한다.
            - 만들어진 프록시에 어드바이저를 연결한다.
        5. 프록시가 생성되면 스프링 컨테이너에 빈으로 등록한다.
    - 빈 후처리기를 사용하면 매번 `ProxyFactoryBean` 빈을 등록하지 않아도 타깃 객체에 프록시를 적용할 수 있다.
- 확장된 포인트컷
    - 기존의 `ProxyFactoryBean`에서는 클래스 레벨의 포인트컷은 필요 없었다.
    - 하지만 자동 프록시 생성기에서는 클래스와 메서드 레벨의 포인트컷 모두 필요하다.
    - 포인트컷의 구성 요소
        - `ClassFilter`: 프록시를 적용할 클래스인지 확인한다.
        - `MethodMatcher`: 어드바이스를 적용할 메서드인지 확인한다.
- 포인트컷 테스트(소스 참고)

### 6.5.2 `DefaultAdvisorAutoProxyCreator`의 적용

- 클래스 필터를 적용한 포인트컷 작성(소스 참고)
- 어드바이저를 이용하는 자동 프록시 생성기 등록(소스 참고)
    - `DefaultAdvisorAutoProxyCreator`는 빈으로 등록된 모든 `Advisor`를 찾는다.
- `ProxyFactoryBean` 제거와 서비스 빈의 원상복구(소스 참고)
- 자동 프록시 생성기를 사용하는 테스트(소스 참고)
    - 정적 멤버 클래스를 지정할 때는 `$` 기호를 사용한다.
    - `<bean>` 태그의 `parent` 속성을 사용하면 다른 빈 설정의 내용을 상속받을 수 있다.
- 자동생성 프록시 확인
    - 자동화 기술은 직접 확인해보는 습관을 들이는게 좋다.
    - 확인 사항
        - 트랜잭션 부가기능 적용 여부
            - 예외가 발생했을 때 롤백 여부를 확인한다.
        - 조건에 맞는 빈에만 적용되는지 확인
            - `getBean("userService")`로 가져온 객체가 JDK의 `Proxy` 타입인지 확인한다.

### 6.5.3 포인트컷 표현식을 이용한 포인트컷

- 지금까지 메서드나 클래스의 이름을 비교해서 선정하는 방식을 사용했다.
- 스프링은 표현식 언어를 사용해서 포인트컷을 작성할 수 있는 방법, 포인트컷 표현식(Pointcut Expression)을 제공한다.
- 포인트컷 표현식
    - `AspectJExpressionPointcut` 클래스를 통해 포인트컷 표현식을 적용할 수 있다.
        - 기존 `Pointcut` 인터페이스와 달리 클래스와 메서드의 선정 알고리즘을 포인트컷 표현식으로 한 번에 지정할 수 있다.
        - 정규식처럼 문자열 기반 표현식으로 복잡한 조건을 지정할 수 있다.
- 포인트컷 표현식 문법
    - 대표적인 지시자는 `execution()`이다.
    - 문법
        ```text
        execution([접근 제한자 패턴] 타입패턴 [타입패턴.]이름패턴 (타입패턴 | "..", ...) [throws 예외 패턴])
        ```
        - `[]`: 옵션 항목으로 생략 가능하다.
        - `|`: OR 조건이다.
    - 예시
        ```text
        public int springbook.learningtest.spring.pointcut.Target.minus(int,int) throws java.lang.RuntimeException
        ```
        - `public`: 접근 제한자 패턴
        - `int`:반환 타입 패턴
        - `springbook.learningtest.spring.pointcut.Target`: 패키지와 타입 이름을 포함한 클래스의 타입 패턴
            - 메서드 이름 패턴과 `.`으로 연결된다.
            - 패키지 이름과 클래스 또는 인터페이스 이름에 `*`를 사용할 수 있고, `..`을 통해 한 번에 여러 개의 패키지를 선택할 수 있다.
        - `minus`: 메서드 이름 패턴
        - `(int,int)`: 메서드 파라미터의 타입 패턴
            - 파라미터가 없는 메서드를 지정하려면 `()`로, 파라미터의 타입과 개수 상관없이 모두 허용한다면 `..`을 사용하면 된다.
        - `throws java.lang.RuntimeException`: 예외 이름에 대한 타입 패턴
- 포인트컷 표현식 테스트(소스 참고)
- 포인트컷 표현식을 이용하는 포인트컷 적용
    - 포인트컷 표현식을 사용하면 문자열 기반이기 때문에 코드와 설정이 단순해진다.
    - 표현식은 문자열이기 때문에 컴파일 타임에 문법 오류나 오타를 확인할 수 없다.
    ```xml
    <bean id="transactionAdvice" class="study.user.service.TransactionAdvice">
        <property name="transactionManager" ref="transactionManager"/>
    </bean>

    <bean id="transactionPointcut" class="org.springframework.aop.aspectj.AspectJExpressionPointcut">
        <property name="expression" value="execution(* *..*ServiceImpl.upgrade*(..))"/>
    </bean>

    <bean id="transactionAdvisor" class="org.springframework.aop.support.DefaultPointcutAdvisor">
        <property name="advice" ref="transactionAdvice"/>
        <property name="pointcut" ref="transactionPointcut"/>
    </bean>
    ```
- 타입 패턴과 클래스 이름 패턴
    - 포인트컷 표현식 적용 전에는 클래스 이름 패턴을 기반으로 타깃 빈을 선정했다.
        - `TestUserService`는 이름 패턴에 맞추기위해 `TestUserServiceImpl`로 클래스명을 변경했다.
    - 포인트컷 표현식은 패턴은 타입 패턴을 기반으로 동작한다.
        - `TestUserService`로 다시 클래스 이름을 변경해도 타입은 슈퍼 클래스인 `UserServiceImpl`, 구현 인터페이스인 `UserService` 모두 적용된다.

### 6.5.4 AOP란 무엇인가?

- 지금까지 `UserService`에 트랜잭션을 적용하는 과정을 단계적으로 발전시켜 왔다.
- 트랜잭션 서비스 추상화
    - 특정 트랜잭션 기술에 종속되는 코드로 인해 트랜잭션 방식을 바꾸려면 모든 트랜잭션 적용 코드 수정이 필요했다.
    - 트랜잭션 코드를 서비스 추상화를 통해 기술 변경에 유연하게 대응 가능해졌다.
- 프록시와 데코레이터 패턴
    - 비즈니스 로직 코드에 트랜잭션을 적용하는 방법이 여전히 코드에 드러나 있다.
    - DI를 이용한 데코레이터 패턴을 통해 비즈니스 로직 클래스에는 영향을 주지 않으면서, 프록시로 트랜잭션 기능을 비즈니스 로직에 적용할 수 있는 구조를 만들었다.
- 다이나믹 프록시와 프록시 팩토리 빈
    - 비즈니스 로직 인터페이스의 모든 메서드에 트랜잭션 기능을 부여하는 코드를 추가해야 했고, 부가기능이 필요하지 않은 메서드조차 프록시로서 위임 기능이 필요했다.
    - JDK 다이나믹 프록시 기술을 적용하여 부가기능 부여 코드가 중복되는 문제를 해결했다.
    - 메서드 선정 패턴을 통해 동적으로 트랜잭션 적용이 필요한 메서드를 선정했다.
- 자동 프록시 생성 방법과 포인트컷
    - 트랜잭션 적용 대상 모두 프록시 팩토리 빈 설정이 필요했다.
    - 스프링 컨테이너의 빈 생성 후처리 기법을 통해 프록시를 적용할 대상을 자동으로 선정할 수 있도록, 클래스를 선정하는 기능을 담은 확장된 포인트컷을 사용했다.
    - 트랜잭션 부가기능을 어디에 적용할 대상을 선정하는 정보를 포인트컷이라는 독립적인 정보로 완전히 분리할 수 있었다.
- 부가기능의 모듈화
    - 부가기능은 기능을 부가할 대상 없이 스스로 독립적인 방식으로 존재하면 적용이 어렵다.
    - 애플리케이션 전반에 여기저기 흩어져 있는 트랜잭션 코드를 어드바이스와 포인트컷을 결합한 어드자이저를 사용해 독립적으로 모듈화시켰다.
- AOP: 애스펙트 지향 프로그래밍
    - 객체지향 기술에서는 부가기능 모듈을 애스펙트(Aspect)라고 부른다.
    - 부가기능을 독립적인 애스팩트로 분리하여 핵심기능은 관심사에 집중할 수 있도록 한다.
    - 애플리케이션에서 핵심기능에서 부가적인 기능을 분리해서 애스펙트로 설계하고 개발하는 방법을 애스펙트 지향 프로그래밍(AOP: Aspect Oriented Programming)이라고 한다.
    - AOP는 새로운 패러다임이 아닌, OOP를 보조하는 기술이다.
        - 핵심기능과 부가기능이 섞이면 객체지향 설계의 장점을 살리기 어렵다.
        - 애스펙트 분리를 통해 핵심기능 설계 시 객체지향적인 가치를 지킬 수 있도록 도와주는 기술이다.
        - 애플리케이션을 다양한 관점에서 독립적으로 모델링하고, 설계하고, 개발할 수 있도록 도와준다.
    - AOP는 특정한 관점을 기준으로 바라볼 수 있게 해주기 때문에 관점 지향 프로그램이라고도 한다.

### 6.5.5 AOP 적용기술

- 프록시를 이용한 AOP
    - 스프링은 프록시(Proxy) 방식을 기반으로 AOP를 지원한다.
    - 프록시 역할
        - DI로 연결된 빈 사이에서 메서드 호출 과정에 참여해 부가기능을 적용한다.
    - 프록시 기반 구조의 장점
        - 핵심 로직과 부가기능의 분리한다.
        - 다양한 객체에 동적으로 애스펙트 적용한다.
        - 설정 기반으로 부가기능을 일괄 적용한다.
- 바이트코드 생성과 조작을 통한 AOP
    - 프록시 방식이 아닌 AOP 기술도 존재한다.
        - 대표적으로 AspectJ는 바이트코드를 조작하는 방식으로 AOP를 구현한다.
    - 적용 방식
        - 컴파일된 타깃의 클래스 파일 자체를 수정한다.
        - 클래스가 JVM에 로딩되는 시점에 바이트코드를 조작한다.
    - 사용하는 이유
        - 스프링 DI 컨테이너 없이 부가기능을 적용할 수 있다.
        - 프록시 방식으로는 지원되지 않는 정적 메서드, 생성자, 필드 접근 등에 AOP를 적용할 수 있다.
    - 일반적으로 프록시 방식의 스프링 AOP로도 충분하다.
    - 필요에 따라 AspectJ를 함께 사용하면 된다.

### 6.5.6 AOP의 용어

- 타깃
    - 부가기능을 부여할 대상
- 어드바이스
    - 부가기능을 담은 모듈
- 조인 포인트(Join Point)
    - 어드바이스가 적용될 수 있는 지점
    - 스프링 AOP에서는 조인 포인트가 메서드 실행 단계뿐이다.
    - 타깃이 구현한 인터페이스의 모든 메서드가 조인 포인트가 된다.
- 포인트컷
    - 어드바이스를 적용할 조인 포인트를 선별하는 기능을 정의한 모듈
- 프록시
    - 클라이언트와 타깃 사이에 투명하게 부가기능을 제공하는 객체
- 어드바이저
    - 포인트컷과 어드바이스를 결합한 객체
- 애스펙트
    - AOP의 기본 모듈
    - 하나 이상의 포인트컷과 어드바이스의 조합으로 만들어진다.
    - 일반적으로 스프링 빈으로 등록된 싱글톤 객체로 존재한다.

### 6.5.7 AOP 네임스페이스

- 스프링 AOP를 적용하기 위해 추가했던 빈들은 스프링 컨테이너에 의해 자동으로 인식돼서 특별한 작업을 위해 사용된다.
- 스프링의 프록시 방식 AOP를 적용하려면 최소 4가지 빈이 필요하다.
    - 자동 프록시 생성기
        - 스프링의 `DefaultAdvisorAutoProxyCreator` 클래스를 빈으로 등록한다.
        - 다른 빈에 주입되거나 참조되지 않고 독립적으로 존재하기 때문에 DI도 필요하지 않다.
        - 빈 후처리기로 동작하며, 컨테이너에 등록된 어드바이저를 검색해 프록시를 자동 생성하는 기능을 담당한다.
    - 어드바이스
        - 부가기능을 구현한 클래스를 빈으로 등록한다.
    - 포인트컷
        - 스프링의 `AspectJExpressionPointcut`을 빈으로 등록한다.
        - `expression` 프로퍼티를 통해 포인트컷 표현식을 명시한다.
    - 어드바이저
        - 스프링의 `DefaultPointcutAdvisor` 클래스를 빈으로 등록한다.
        - 어드바이스와 포인트컷을 참조한다.
        - 자동 프록시 생성기에 의해 검색되어 자동 적용된다.
    - AOP 네입스페이스
        - 스프링은 AOP와 관련된 태그를 정의해둔 `aop` 스키마를 제공한다.
            ```xml
            <aop:config>
                <aop:pointcut id="transactionPointcut" expression="execution(* *..*ServiceImpl.upgrade*(..))"/>
                <aop:advisor advice-ref="transactionAdvice" pointcut-ref="transactionPointcut"/>
            </aop:config>
            ```
            - `<aop:config>`
                - AOP 설정을 담는 부모 태그
                - 필요에 따라 `AbstractAdvisorAutoProxyCreator`를 빈으로 등록한다.
            - `<aop:pointcut>`
                - 포인트컷 표현식을 가진 `AspectJExpressionPointcut`을 빈으로 등록한다.
            - `<aop:advisor>`
                - `DefaultBeanFactoryPointcutAdvisor`를 빈으로 등록한다.
                - `advice-ref`와 `pointcut-ref`를 통해 어드바이스와 포인트컷을 연결한다.
    - 어드바이저 내장 포인트컷(소스 참고)
        - 여러 어드바이저에서 동일한 포인트컷을 공유하려면, `<aop:pointcut>`을 독립적으로 등록하고 `id`를 부여한 후 `pointcut-ref`로 참조하면 된다.
        - 포인트컷을 한 번만 사용할 경우 `<aop:advisor>` 안에서 직접 정의한다.

## 6.6 트랜잭션 속성

- 트랜잭션 추상화에서 트랜잭션을 시작할 때 사용했던 `DefaultTransactionDefinition` 객체에 대해 알아본다.

### 6.6.1 트랜잭션 정의

- 트랜잭션은 다양한 방식으로 동작한다.
    - 트랜잭션은 논리적 작업의 최소 단위로, 실패하면 전체 작업을 `rollback`하고, 성공하면 `commit`되어야 한다.
- 트랜잭션 전파(Transaction Propagation)
    - 트랜잭션의 경계에서 이미 진행 중인 트랜잭션이 있을 때 또는 없을 때 어떻게 동작할 것인가를 결정하는 방식이다.
    - 트랜잭션 전파 속성
        - `PROPAGATION_REQUIRED`
            - 진행 중인 트랜잭션이 있으면 참여하고, 없으면 새로 시작한다.
            - `DefaultTransactionDefinition`의 트랜잭션 전파 속성이다.
        - `PROPAGATION_REQUIRES_NEW`
            - 항상 새로운 트랜잭션을 시작한다.
            - 기존 트랜잭션과는 독립적으로 수행된다.
        - `PROPAGATION_NOT_SUPPORTED`
            - 트랜잭션 없이 동작한다.
            - 전체 AOP 적용 중 특정 메서드만 트랜잭션을 제외해야 할 때 사용한다.
    - `getTransaction()` 메서드를 호출하더라도, 트랜잭션 전파 속성에 따라 실제로 트랜잭션이 새로 시작되거나 기존 트랜잭션에 참여하게 된다.
- 격리 수준(Isolation Level)
    - 동시에 실행되는 트랜잭션 간의 발생할 수 있는 문제를 방지하기 위한 설정이다.
        - 모든 트랜잭션을 순차적으로 처리한다면 성능이 저하될 수 있다.
    - 격리 수준 재설정
        - 기본적으로 DB에 설정되어 있다.
        - JDBC 드라이버나 `DataSource` 등에서 재설정 할 수 있다.
        - 필요에 따라 트랜잭션 단위로 격리 수준을 조정할 수 있다.
- 제한시간(Timeout)
    - 트랜잭션을 수행하는 시간을 제한할 수 있다.
    - `DefaultTransactionDefinition`의 기본 설정은 제한시간이 없다.
    - `PROPAGATION_REQUIRED`나 `PROPAGATION_REQUIRES_NEW`와 함께 사용할 때 의미가 있다.
- 읽기 전용(Read Only)
    - 트랜잭션을 읽기 전용으로 설정하여 데이터 조작을 막을 수 있다.
    - 데이터 액세스 기술에 따라 성능을 최적화할 수 있다.
- 트랜잭션의 정의 속성은 `TransactionAdvice`에서 사용하는 `TransactionDefinition` 객체를 외부에서 DI받아 설정 할 수 있다.
    - 하나의 `TransactionAdvice`에 설정된 속성은 해당 어드바이스를 사용하는 모든 트랜잭션에 동일하게 적용된다.

### 6.6.2 트랜잭션 인터셉터와 트랜잭션 속성

- 트랜잭션의 동작 방식을 메서드별로 다르게 적용하기 위해서는 트랜잭션 어드바이스의 기능을 확장해야 한다.
- `TransactionInterceptor`
    - 스프링이 제공하는 트랜잭션 경계 설정 어드바이스
    - 메서드 이름 패턴에 따라 서로 다른 트랜잭션 속성을 적용할 수 있도록 해준다.
    - `Properties` 타입의 프로퍼티를 통해 부가기능의 동작 방식을 제어할 수 있다.
        - 기본적인 두 가지 종류의 예외 처리 방식
            - 언체크 예외(런타임 예외)
                - 트랜잭션 롤백
            - 체크 예외
                - 트랜잭션 커밋(비즈니스 로직에 따른 리턴 방식으로 인식)
        - `rollbackOn()` 속성을 이용해 롤백 대상 예외를 지정할 수 있다.
- 메서드 이름 패턴을 이용한 트랜잭션 속성 지정
    - `Properties` 타입의 프로퍼티는 메서드 패턴과 트랜잭션 속성을 키와 값으로 갖는 컬렉션
    - 트랜잭션 속성은 문자열로 정의할 수 있다.
        ```text
        PROPAGATION_NAME, ISOLATION_NAME, readonly, timeout_NNNN, -Exception1, +Exception2
        ```
        - `PROPAGATION_NAME`: 트랜잭션 전파 방식 (필수)
        - `ISOLATION_NAME`: 격리 수준 (선택)
        - `readonly`: 읽기 전용 여부
        - `timeout_NNNN`: 제한시간 (단위: 초)
        - `-Exception1`: 체크 예외도 롤백 대상에 포함
        - `+Exception2`: 언체크 예외지만 롤백하지 않음
        ```xml
        <bean id="transactionAdvice" class="org.springframework.transaction.interceptor.TransactionInterceptor">
            <property name="transactionManager" ref="transactionManager"/>
            <property name="transactionAttributes">
                <props>
                    <prop key="get*">PROPAGATION_REQUIRED, readOnly,timeout_30</prop>
                    <prop key="upgrade*">PROPAGATION_REQUIRED_NEW, ISOLATION_SERIALIZABLE</prop>
                    <prop key="*">PROPAGATION_REQUIRED</prop>
                </props>
            </property>
        </bean> 
        ```
- `tx` 네임스페이스를 이용한 설정 방법(소스 참고)
    - 속성명을 통해 분리하여 지정 가능하기 때문에 가독성이 좋다.
    - XML 자동완성 기능을 사용할 수 있다.
    - XML 스키마에 미리 등록해둔 값을 통해 오타를 검출 할 수 있다.

### 6.6.3 포인트컷과 트랜잭션 속성의 적용 전략

- `aop`와 `tx` 스키마의 전용 태그를 사용하면 애플리케이션의 어드바이저, 어드바이스, 포인트컷 기본 설정을 변경하지 않고 트랜잭션 속성을 수정할 수 있다.
- 트랜잭션 포인트컷 전략
    - 표현식은 타입 패턴이나 빈 이름을 기준으로 포인트컷을 작성한다.
    - 트랜잭션 적용 대상 클래스의 모든 메서드에 트랜잭션을 적용하는 것을 권장한다.
        - 조회 메서드는 트랜잭션 속성 읽기전용 설정을 통해 성능을 향상시킬 수 있다.
        - 격리 수준에 따라 트랜잭션 내에서 실행 할 필요가 있다.
- 트랜잭션 포인트컷 주의사항
    - 메서드나 파라미터, 예외를 기준으로 포인트컷을 작성하는 것은 바람직하지 않다.
    - 가능하면 인터페이스 타입을 기준으로 타입 패턴 적용을 권장한다.
- 포인트컷 표현식 종류
    - `execution()`: 메서드 실행 시점을 기준으로 포인트컷 설정
    - `bean()`: 빈 이름을 기준으로 타깃 지정
        - 클래스/인터페이스 이름에 일정한 규칙을 만들기 어려운 경우 유용하다.
        - 표현식이 간결하다.
    - 어노테이션 기반 포인트컷 표현식: 클래스 또는 메서드에 붙은 애노테이션을 기준으로 타깃 지정
- 공통된 메서드 이름 규칙을 통한 트랜잭션 속성 관리 전략
    - 메서드 이름 패턴을 활용해 트랜잭션 속성을 최소 설정으로 통합 관리한다.
    - 기준이 되는 트랜잭션 속성 정책을 정의한다.
        ```xml
        <tx:advice id="transactionAdvice">
            <tx:attributes>
                <tx:method name="*"/>
            </tx:attributes>
        </tx:advice>
        ```
    - 필요에 따라 메서드 명명 규칙을 통해 속성을 세분화해서 관리한다.
        ```xml
        <tx:advice id="transactionAdvice">
            <tx:attributes>
                <tx:method name="*"/>
                <tx:method name="get*" read-only="true"/>
            </tx:attributes>
        </tx:advice>
        ```
    - 특별한 트랜잭션 설정이 필요한 경우, 별도의 어드바이스 및 포인트컷 정의한다.
        ```xml
        <aop:config>
            <aop:advisor advice-ref="transactionAdvice" pointcut="execution(* *..*ServiceImpl.upgrade*(..))"/>
            <aop:advisor advice-ref="batchTxAdvice" pointcut="execution(* *..*BatchJob.*(..))"/>
        </aop:config>
        ```
- 프록시 방식 AOP의 한계
    - 같은 타깃 객체 내부 메서드를 호출하는 경우 부가기능이 적용되지 않는다.
        - 스프링의 AOP는 프록시 객체를 통해 타깃 객체를 감싸고, 클라이언트 호출 시 프록시가 부가기능을 적용한 후 실제 타깃 메서드를 실행한다.
        - 타깃 객체가 자기 자신의 메서드를 호출할 때는 프록시를 거치지 않아 부가기능이 적용되지 않는다.
    - 해결 방법
        - 프록시 강제 호출
            - AOP 프록시 객체를 직접 주입받아 내부 메서드 호출한다.
            - 비즈니스 로직에 스프링 API와 프록시 코드가 존재하기 때문에 권장하지 않는다.
        - AspectJ와 같이 바이트코드를 직접 조작하는 방식의 AOP 기술 적용
            - 대부분의 기존 설정은 그대로 둔 채로 간단한 옵션을 통해 AspectJ 방식으로 트랜잭션 AOP를 적용되게 할 수 있다.
            - 하지만 그만큼 다른 불편도 뒤따르기 때문에 꼭 필요한 경우만 사용해야 한다.
            - AspectJ를 통한 AOP 방법은 14장에서 알아본다.

### 6.6.4 트랜잭션 속성 적용

- 트랜잭션 경계설정의 일원화
    - 트랜잭션 경계설정의 부가기능은 비즈니스 로직을 담고 있는 서비스 계층의 트랜잭션 경계와 일치시키는 것을 권장한다.
    - 다른 계층이나 모듈에서 DAO에 직접 접근하는 것을 차단하고, 서비스 계층의 위임 메서드를 통해 접근해야 한다.
        - 부가기능 로직을 적용할 수 있다.
        - 트랜잭션 속성을 제어할 수 있다.
- 서비스 빈에 적용되는 포인트컷 표현식 등록
    ```xml
    <aop:config>
        <aop:advisor advice-ref="transactionAdvice" pointcut="bean(*Service)"/>
    </aop:config>
    ```
- 트랜잭션 속성을 가진 트랜잭션 어드바이스 등록
    ```xml
    <tx:advice id="transactionAdvice">
        <tx:attributes>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="*"/>
        </tx:attributes>
    </tx:advice>
    ```
- 트랜잭션 속성 테스트(소스 참고)
    - `TransientDataAccessResourceException`
        - 스프링의 `DataAccessException`의 한 종류로, 일시적인 예외상황에서 발생하는 예외다.
        - 일시적 예외란 재시도를 하면 성공할 가능성이 있다는 의미다.

## 6.7 어노테이션 트랜잭션 속성과 포인트컷

- 포인트컷 표현식과 트랜잭션 속성을 이용해 트랜잭션을 일괄 적용하는 방식은 대부분의 상황에서 사용할 수 있다.
- 메서드별로 다른 트랜잭션 속성이 필요할 경우 패턴 기반 설정은 적합하지 않다.
    - 매번 포인트컷과 어드바이스를 추가해야 한다.
    - 포인트컷 자체와 설정 파일이 복자해진다.
- 스프링은 어노테이션을 통해 부가기능을 적용할 수 있는 방법을 지원한다.

### 6.7.1 트랜잭션 어노테이션

- `@Transactional`
    - 트랜잭션 속성을 메서드와 클래스, 인터페이스에 사용할 수 있는 어노테이션이다
    - `@Transactional` 어노테이션을 사용하는 경우, 스프링은 해당 어노테이션이 붙은 객체를 자동으로 트랜잭션 부가기능의 타깃 객체로 인식한다.
    - `TransactionAttributeSourcePointcut` 포인트컷이 사용된다.
        - `@Transactional` 어노테이션이 부여된 빈 객체들을 모두 찾아 선정 결과로 반환한다.
    - 트랜잭션 속성 정의와 동시에 포인트컷의 자동등록에도 사용된다.
- 트랜잭션 속성을 이용하는 포인트컷
    - `TransactionInterceptor`는 `AnnotationTransactionAttributeSource`를 사용한다.
    - `TransactionInterceptor`는 `AnnotationTransactionAttributeSource`를 통해 트랜잭션 속성을 읽어온다.
    - 메서드마다 트랜잭션 속성을 다르게 설정할 수 있다.
- 대체 정책
    - 스프링은 `@Transactional`을 적용할 때 4단계의 대체(Fallback) 정책을 사용한다.
        - 타깃 메서드, 타깃 클래스, 선언 메서드, 선언 타입(클래스, 인터페이스) 순으로 `@Transactional` 속성정보를 사용한다.
    - 적용 전략
        - 공통 속성은 먼저 타입 레벨에 부여한다.
        - 공통 속성을 따르지 않는 예외적인 메서드에 대해서만 메서드 레벨에 `@Transactional`을 부여한다.
        - 인터페이스에 `@Transactional`을 적용할 수 있다.
            - 구현 클래스와 상관없이 트랜잭션 속성을 유지할 수 있다.
            - 하지만 프록시 방식의 AOP에서만 유효하다.
            - 안전하게 타깃 클래스에 적용하는 것을 권장한다.
- 트랜잭션 어노테이션 사용을 위한 설정(소스 참고)

### 6.7.2 트랜잭션 어노테이션 적용

- `@Transactional` 어노테이션은 사용이 간편하고 가독성이 좋다.
- 단점
    - 트랜잭션 적용 대상을 일괄적으로 파악하기 어렵다.
    - 명확한 사용 정책이 없다면 무분별하게 사용되거나, 누락될 위험이 있다.
    - 트랜잭션 적용 여부를 런타임까지 알기 어렵다.
        - 트랜잭션이 없어도 메서드는 정상적으로 실행되기 때문에 문제가 발생하지 않는다.
        - 예외가 발생해 롤백이 필요한 상황에서는 문제를 발견할 수 있다.

## 6.8 트랜잭션 지원 테스트

### 6.8.1 선언적 트랜잭션과 전파 속성

- 트랜잭셔을 정의할 때 전파 속성은 유용한 개념이다.
    - `REQUIRED` 전파 속성을 가진 메서드를 결합해서 다양한 단위의 트랜잭션 작업을 만들 수 있다.
    - 트랜잭션 전파 속성을 이용하면 중복 코드를 줄일 수 있다.
        - 전파 속성이 없다면, 한 트랜잭션에 묶어야 하는 작업이 있을 때 `UserService.add()`의 내부 코드를 복사해서 사용해야 한다.
    - 애플리케이션을 작은 기능 단위로 분리해서 개발할 수 있다.
- 선언적 트랜잭션(Declarative Transaction)
    - AOP를 이용하여 코드 외부에서 트랜잭션 기능을 부여하고, 속성을 지정할 수 있는 방식이다.
- 프로그래밍 방식 트랜잭션(Programmatic Transaction)
    - `TransactionTemplate` 또는 `PlatformTransactionManager` 등을 이용해 코드 내부에서 직접 트랜잭션을 제어하는 방식이다.
- 스프링은 두 방식 모두 지원하지만, 특별한 경우가 아니라면 선언적 트랜잭션 방식을 권장한다.

### 6.8.2 트랜잭션 동기화와 테스트

- AOP와 스프링의 트랜잭션 추상화를 통해 자유로운 전파와 유연한 트랜잭션 적용이 가능했다.
    - AOP 기반 프록시를 이용해 간단하게 트랜잭션 부가기능을 적용할 수 있다.
    - 스프링의 트랜잭션 추상화는 데이터 액세스 기술이나 트랜잭션 기술 종류에 상관없이 일관된 트랜잭션 처리를 가능하게 한다.
- 트랜잭션 매니저와 트랜잭션 동기화
    - 트랜잭션 추상화의 핵심은 트랜잭션 매니저와 트랜잭션 동기화다.
        - 트랜잭션 매니저(`PlatformTransactionManager`)
            - 다양한 트랜잭션 기술을 일관된 방식으로 제어할 수 있도록 도와주는 인터페이스다.
        - 트랜잭션 동기화
            - 트랜잭션 동기화 기술을 통해 DAO, 서비스 계층 등에서 트랜잭션 정보를 공유할 수 있다.
            - 전파 속성을 통해 트랜잭션에 참여하거나 새로 생성할지 결정할 수 있다.
    - 필요 시 직접 트랜잭션 매니저를 이용해서 트랜잭션에 참여할 수 있다.
- 트랜잭션 매니저를 이용한 테스트용 트랜잭션 제어
- 트랜잭션 동기화 검증
    - 선언적 트랜잭션 뿐만 아니라 `JdbcTemplate`과 같이 스프링이 제공하는 데이터 액세스 추상화를 적용한 DAO에도 영향을 미친다.
    ```java
    @Test
    void transactionSync() {
        assertThrows(TransientDataAccessResourceException.class, () -> {
            DefaultTransactionDefinition transactionDefinition = new DefaultTransactionDefinition();
            transactionDefinition.setReadOnly(true);

            TransactionStatus transactionStatus = transactionManager.getTransaction(transactionDefinition);

            userService.deleteAll();

            userService.add(users.get(0));
            userService.add(users.get(1));

            transactionManager.commit(transactionStatus);
        });
    }
    ```
- 롤백 테스트
    - 테스트 수행 중 변경한 데이터를 트랜잭션 롤백을 통해 초기화하여, 테스트 실행 전 상태로 되돌리는 방식이다.
    - 테스트 결과와 상관없이 테스트 하는 동안 조작한 데이터를 모두 롤백 하고, 테스트 시작 전 상태를 유지하기 때문에 유용하다.
    - 공통 테스트 데이터는 사전에 DB에 삽입할 수 있다.
    - 적절한 트랜잭션 격리 수준을 설정하면 여러 테스트가 동시에 실행돼도 영향을 주지 않는다.
    - 일반적으로 롤백이 커밋보다 성능이 좋지만, 트랜잭션 처리 방식에 따라 롤백이 더 많은 부하를 주는 경우도 있기 때문에 단지 성능 측면에서 롤백 테스트가 좋다고 단정할 수 없다.

### 6.8.3 테스트를 위한 트랜잭션 어노테이션

- `@Transactional`은 클래스나 인터페이스에 부여하는 것만으로 트랜잭션을 적용할 수 있는 편리한 기능이다.
- `@Transactional`은 테스트 클래스와 메서드에도 적용할 수 있다.
- 스프링의 컨텍스트 테스트 프레임워크는 어노테이션 기반 테스트를 더욱 편리하게 만들 수 있는 여러 기능을 지원한다.
    - `@ContextConfiguration`을 클래스에 부여하면 테스트 실행 전 스프링 컨테이너를 초기화한다.
    - `@Autowired`가 적용된 필드를 통해 테스트에 필요한 빈에 자유롭게 접근할 수 있다.
- `@Transactional`
    - 테스트 클래스나 메서드에 `@Transactional`을 부여하면 트랜잭션 경계가 자동으로 설정된다.
    - 이를 통해 테스트 중에 발생하는 모든 트랜잭션 관련 작업을 하나로 묶어 처리할 수 있다.
    - 이란 경우 `@Transactional`은 AOP를 위한 것이 아니라, 스프링의 컨텍스트 테스트 프레임워크에 의해 트랜잭션이 적용된다.
- `@Rollback`
    - 테스트에서 사용되는 `@Transactional`은 기본적으로 트랜잭션을 강제로 롤백하도록 설정되어 있다.
    - `@Rollback`을 사용하면 테스트 중에 수행한 작업을 실제 DB에 반영할 수 있다.
    - `@Transactional` 자체에는 롤백 여부를 설정하는 기능이 없기 때문에, 별도의 어노테이션이 필요하다.
    - 트랜잭션을 적용하되 롤백을 원하지 않는 경우, `@Rollback(false)`로 설정한다.
- `@TransactionConfiguration`
    - 테스트 클래스 내의 모든 메서드에 공통적인 트랜잭션 속성을 적용힐 때 유용하다.
- `NotTransactional`과 `Propagation.NEVER`
    - 특정 메서드에만 트랜잭션이 필요하다면 메서드 레벨에서 `@Transactional`을 사용하고, 대부분의 메서드에 트랜잭션이 필요하다면 클래스에 `@Transactional`을 지정하는 것이 편리하다.
    - `@NotTransactional`을 메서드에 부여하면 클래스 수준의 `@Transactional` 설정을 무시할 수 있다.
        - 단, 이 어노테이션은 스프링 3.0 이후로 Deprecated 되었다.
    - 트랜잭션 전파 속성을 `Propagation.NEVER`로 설정하면 트랜잭션이 시작되지 않도록 할 수 있다.
- 효과적인 DB 테스트
    - 단위 테스트처럼 고립된 상태에서 실행되는 테스트와, 여러 계층이 참여하는 통합 테스트는 별도의 클래스로 만드는 것이 좋다.
        - 통합 테스트 클래스에는 보통 클래스 레벨에 `@Transactional`을 부여한다.
        - 통합 테스트를 롤백 테스트로 작성하면 공통 테스트 DB를 미리 셋업한 뒤, 각 테스트가 필요한 데이터를 보충해서 실행할 수 있다.
        - 롤백 기반 테스트는 독립적이고 자동화된 테스트 작성에 적합하다.
    - 테스트는 어떤 경우에도 서로 의존해서는 안 된다.
    - 트랜잭션을 지원하는 롤백 테스트는 유용한 도구가 될 수 있다.

## 6.9 정리

- 트랜잭션 경계설정 코드를 분리해서 별도의 클래스로 만들고 비즈니스 로직 클래스와 동일한 인터페이스를 구현하면 DI의 확장 기능을 이용해 클라이언트의 변경 없이도 깔끔하게 분리된 트랜잭션 부가기능을 만들 수 있다.
- 트랜잭션처럼 환경과 외부 리소스에 영향을 받는 코드를 분리하면 비즈니스 로직에만 충실한 테스트를 만들 수 있다.
- 목 객체를 활용하면 의존관계 속에 있는 객체도 손쉽게 고립된 테스트로 만들 수 있다.
- DI를 이용한 트랜잭션의 분리는 데코레이터 패턴과 프록시 패턴으로 이해될 수 있다.
- 번거로운 프록시 클래스 작성은 JDK의 다이나믹 프록시를 사용하면 간단하게 만들 수 있다.
- 다이나믹 프록시는 `static` 팩토리 메서드를 사용하기 때문에 빈으로 등록하기 번거롭다. 따라서 팩토리 빈으로 만들어야 한다. 스프링은 자동 프록시 생성 기술에 대한 추상화 서비스를 제공하는 프록시 팩토리 빈을 제공한다.
- 프록시 팩토리 빈의 설정이 반복되는 문제를 해결하기 위해 자동 프록시 생성기와 포인트컷을 활용할 수 있다. 자동 프록시 생성기는 부가기능이 담긴 어드바이스를 제공하는 프록시를 스프링 컨테이너 초기화 시점에 자동으로 만들어준다.
- 포인트컷은 AspectJ 포인트컷 표현식을 사용해서 작성하면 편리하다.
- AOP는 OOP만으로는 모듈화하기 힘든 부가기능을 효과적으로 모듈화하도록 도와주는 기술이다.
- 스프링은 자주 사용되는 AOP 설정과 트랜잭션 속성을 지정하는 데 사용할 수 있는 전용 태그를 제공한다.
- AOP를 이용해 트랜잭션 속성을 지정하는 방법에는 포인트컷 표현식과 메서드 이름 패턴을 이용하는 방법과 타깃에 직접 부여하는 `@Transactional` 어노테이션을 사용하는 방법이 있다.
- `@Transactional`을 이용한 트랜잭션 속성을 테스트에 적용하면 손쉽게 DB를 사용하는 코드의 테스트를 만들 수 있다.
