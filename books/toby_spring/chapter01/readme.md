# 1장 - 오브젝트와 의존관계

- 스프링의 핵심 철학
    - 객체지향 기술의 가치 회복
    - 객체지향 프로그래밍이 제공하는 혜택을 누릴 수 있도록 기본으로 돌아가자
- 객체에 대한 관심
    - 객체가 생성되고, 다른 객체와 관계를 맺고, 사용되고, 소멸하기까지의 전 과정
- 객체의 설계
    - OOD(Object oriented design) 기초와 원칙
    - 디자인 패턴: 다양한 목적에 부합되게 재활용 가능한 설계
    - 리팩토링: 지속적인 구조 개선
    - 단위 테스트: 객체의 동작이 기대한 대로 되는지 검증
- 스프링이 제공하는 것
    - 객체를 효과적으로 설계하고, 구현하고, 사용하고, 개선해나가야 하는지에 대한 명쾌한 기준 제시
    - 검증된 베스트 프렉티스 제공
        - 객체지향 기술
        - 설계, 구현에 관한 실용적 전략

## 1.1 초난감 DAO

> DAO
>
> DAO(Data Access Object)는 DB를 사용해 데이터를 조회하거나 조작하는 역할을 하는 객체

### 1.1.1 User(소스 참고)

- 사용자 정보를 저장하는 클래스

> 자바빈
>
> 자바빈(JavaBean)은 다음 두 가지 관례를 따라 만들어진 객체
> - 디폴트 생성자: 자바빈은 프레임워크에서 리플렉션을 이용해 객체를 생성하기 때문에 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다.
> - 프로퍼티: 자바빈이 노출하는 이름을 가진 속성
    >
- set으로 시작하는 수정자 메서드
>   - get으로 시작하는 접근자 메서드

### 1.1.2 UserDao(소스 참고)

- 사용자 정보를 DB 넣고 관리할 수 있는 클래스
- JDBC를 이용한 작업 순서
    - DB 연결을 위한 `Connection`을 가져온다.
    - SQL을 담은 `Statement`(또는 `PreparedStatement`)를 만든다.
    - 만들어진 `Statement`를 실행한다.
    - 조회의 경우 SQL 쿼리의 실행 결과를 `ResultSet`으로 받아서 정보를 저장할 객체에 옮겨준다.
    - 작업 중에 생성된 `Connection`, `Statement`, `ResultSet` 같은 리소스는 작업을 마친 후 반드시 닫아준다.
    - JDBC API가 만들어내는 예외(Exception)를 잡아서 직접 처리하거나, 메소드에 throws를 선언해서 예외가 발생하면 메소드 밖으로 던지게 한다.

### 1.1.3 main()을 이용한 DAO 테스트 코드(소스 참고)

- `main()`: 클래스 자신을 엔트리 포인트로 설정해 직접 실행 가능하게 해주는 스태틱 메서드

## 1.2 DAO의 분리

### 1.2.1 관심사의 분리

- 객체지향의 세계에서는 모든 것이 변하기 때문에 "미래의 변화를 어떻게 대비할 것인가?"를 가장 염두에 둬야 한다.
- 분리와 확장을 고려한 설계를 통해 변화의 폭을 최소한으로 줄여야 한다.
    - 모든 변경과 발전은 한 번에 한 가지 관심사항에 집중해서 일어난다.
    - 관심사의 분리(Separation of Concerns)를 통해 관심이 같은 것끼리 모으고, 관심이 다른 것은 따로 떨어져 있어야 한다.

### 1.2.2 커넥션 만들기의 추출

- `UserDao`의 관심사항
    - DB와 연결을 위한 커넥션을 가져온다.
    - 사용자 등록을 위해 DB에 보낼 SQL 문장을 담을 `Statement`를 만들고 실행한다.
    - 사용한 리소스 객체(`Statement`, `Connection`)를 닫아야 한다.
- 중복 코드의 메서드 추출
    ```java
    private Connection getConnection() throws ClassNotFoundException, SQLException {
        Class.forName("com.mysql.jdbc.Driver");
        return DriverManager.getConnection("jdbc:mysql://localhost:3306/study", "root", "1q2w3e4r!");
    }
    ```

- 중복코드를 단일 class 안에서 하나의 메소드로 추출한다.

### 1.2.3 DB 커넥션 만들기의 독립

- 여러 확장 방법이 존재한다.
- 상속을 통한 확장
    - DB 커넥션 연결이라는 관심을 분리
    - 상속을 통해 서브 클래스에 관심사를 둔다.
        - `UserDao`: 어떻게 데이터를 가져올 것인가(SQL작성, 파라미터 바인딩, 쿼리 실행, 검색정보 전달)라는 관심을 담당한다.
        - `NUserDao`/`DUserDao`: DB 연결은 어떻게 할 것인가라는 관심을 가지고 있다.
    - 템플릿 메소드 패턴(Template Method Pattern)
        - 슈퍼 클래스
            - 로직의 기본흐름
            - 기능 일부를 추상 메소드나 오버라이딩 가능 메소드를 제공한다.
        - 서브 클래스
            - 추상 메소드나 오버라이딩 가능 메소드를 필요에 맞게 구현해서 사용한다.
    - 펙토리 메소드 패턴(Factory Method Pattern)
        - `getConnection()`
        - 슈퍼 클래스: `Connection` 타입 객체를 생성하는 메서드 정의만 한다.
        - 서브 클래스: 구체적인 객체의 생성 방법을 결정한다.
    - 상속 자체가 가지고 있는 문제
        - `UserDao`가 다른 목적을 위해 상속을 사용하고 있다면, 자바는 다중상속을 허용하지 않는다.
        - 슈퍼클래스 내부의 변경이 서브클래스에 영향을 준다.

> 디자인 패턴
>
> 소프트웨어 설계 시 특정 상황에 자주 만나는 문제를 해결하기 위해 재사용 가능한 솔루션

## 1.3 DAO의 확장

- 모든 객체는 관심사에 따라 변화의 특징이 있다.
- 변화의 성격이 다르다는 건 변화의 이유와 시기, 주기 등이 다르다는 뜻이다.

### 1.3.1 클래스의 분리

- 두 개의 관심사를 독립적인 클래스로 만든다.
- `SimpleConnectionMaker` 클래스에서 DB 생성 기능을 관리한다.
- `UserDao`에서는 `SimpleConnectionMaker`  객체를 만들어서 저장해두고 이를 계속 사용한다.

```java
private SimpleConnectionMaker simpleConnectionMaker;

public UserDao() {
    this.simpleConnectionMaker = new SimpleConnectionMaker();
}
```

- 새로운 문제점
    - `UserDao`의 코드가 `SimpleConnectionMaker` 라는 특정 클래스에 종속되어있다.
        - 코드의 수정 없이 DB 커넥션을 변경할 방법이 없다.
    - `UserDao`는 DB 커넥션을 제공하는 구체적인 클레스를 알고 있어야 한다.
    - 결과적으로 확장성이 떨어진다.

### 1.3.2 인터페이스의 도입

- 추상화를 통해 두 개의 클래스 중간에 느슨한 연결고리를 만들어주는 방법으로 문제를 해결할 수 있다.
- 추상화
    - 어떤 것들의 공통적인 성격을 뽑아내어 이를 따로 분리해내는 작업
    - 추상화를 제공하는 가장 유용한 도구는 인터페이스다.
- 인터페이스
    - 자신을 구현한 클래스에 대한 구체적 정보를 모두 감춘다.
    - 클라이언트는 인터페이스를 통해 원하는 기능만 사용하면 된다.
    - 인터페이스를 통해 접근하면 실제 구현 클래스가 바뀌어도 영향이 없다.

```java
private ConnectionMaker connectionMaker;

public UserDao() {
    this.connectionMaker = new DConnectionMaker();
}
```

- `DConnection` 객체를 생성하는 코드가 여전히 남아있다.

### 1.3.3 관계설정 책임의 분리

- `ConnectionMaker` 구현 클래스를 결정하는 것도 하나의 관심사다.
- 클라이언트는 자기가 사용할 `ConnectionMaker`를 선택하고, 선택한 클래스의 객체를 생성해서 `UserDao`와 연결해줄 수 있다.

```java
public class UserDao {

    private ConnectionMaker connectionMaker;

    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }

    // ...
}

public class UserDaoTest {

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);

        // ...
    }
}
```

### 1.3.4 원칙과 패턴

- 개방 폐쇄 법칙(OCP, Open-Closed Principle)
    - 클래스나 모듈은 확장에는 열려 있어야 하고 변경에는 닫혀 있어야 한다.
    - `UserDao` DB 연결 기능을 확장하는데 열려있다.
    - `UserDao` 자신의 핵심 기능을 구현한 코드는 DB 연결기능의 변화에 영향없이 유지할수 있다.
        - 인터페이스를 통해 제공되는 확장 포인트는 개방되어 있다.
        - 인터페이스를 이용하는 클래스는 자신의 변화가 불필요하게 일어나지 않도록 폐쇄되어 있다.

> 객체지향 설계 원칙(SOLID)
>
> 객체지향의 특징을 잘 살릴 수 있는 5가지 특징
> - SRP(The Single Responsibility Principle): 단일 책임 원칙
> - OCP(The Open Closed Principle): 개방 폐쇄 원칙
> - LSP(The Liskov Substitution Principle): 리스코프 치환 원칙
> - ISP(The Interface Segregation Principle): 인터페이스 분리 원칙
> - DIP(The Dependency Inversion Principle): 의존관계 역전 원칙

- 높은 응집도와 낮은 결합도(High coherence and low coupling)
    - 높은 응집도
        - 하나의 모듈, 클래스가 하나의 책임 또는 관심사에만 집중되어 있다.
        - 변화가 일어날 때 해당 모듈에서 변하는 부분이 크다.
    - 낮은 결합도
        - 책임과 관심사가 다른 객체 또는 모듈과는 느슨하게 연결된 형태를 유지하는 것이 좋다.
        - 느슨한 연결은 관계를 유지하는데 필요한 최소한의 방법만 간접적 형태로 제공하고, 나머지는 서로 독립적이고 알 필요도 없게 만들어 주는 것이다.
        - 결합도란 하나의 객체가 변경이 일어날 때 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도를 말한다.
    - `UserDao`는 `ConnectionMaker`의 관계는 인터페이스를 통해 매우 느슨하게 연결되어 있다.
    - `UserDao`입장에서는 구체적인 `ConnectionMaker` 구현 클래스의 구현 방법이나 전략, 내부적으로 사용하는 객체에 대해서 알 필요 없다.
- 전략 패턴(Strategy Pattern)
    - 독립적인 책임으로 분리하게 하는 디자인 패턴
    - 자신의 기능 맥락(Context)에서, 필요에 따라 변경이 필요한 알고리즘을 인터페이스를 통해 통째로 외부로 분리한다.
    - 인터페이스를 구현한 구체적인 알고리즘 클래스를 필요에 따라 바꿔서 사용할 수 있다.
- 스프링은 객체지향적인 설계 원칙과 디자인 패턴에 나타난 장점을 자연스럽게 개발자들이 활용할 수 있게 해주는 프레임워크다.

## 1.4 제어의 역전(IoC)

### 1.4.1 오브젝트 팩토리

- 클라이언트인 `UserDaoTest` 2가지 책임을 가지고 있다.
    - 기능이 잘 동작하는지 검증
    - `UserDao`와 `ConnectionMaker` 생성 및 관계 설정
- 팩토리(소스 참고)
    - 객체의 생성 방법을 결정하고 만들어진 객체를 반환하는 역할을 한다.
- 설계도로서의 팩토리
    - `UserDao`와 `ConnectionMaker`는 핵심적인 데이터 로직과 기술 로직을 담당한다.
    - `DaoFactory`는 에플리케이션의 객체들을 구성하고, 관계를 정의하는 책임을 맡고 있다.

![Image](https://github.com/user-attachments/assets/f6037830-246c-4130-b49e-f2c69bab4474)

### 1.4.2 오브젝트 팩토리의 활용

- 다양한 DAO 생성 기능이 필요할 때, `userDao()` 메서드를 복사해서 만든다면 `ConnectionMaker` 구현 클래스의 객체를 생성하는 코드가 반복된다.
    ```java
    public class DaoFactory {
  
        public UserDao userDao() {
            return new UserDao(new DConnectionMaker());
        }
  
        public AccountDao accountDao() {
            return new AccountDao(new DConnectionMaker());
        }
  
        public MessageDao messageDao() {
            return new MessageDao(new DConnectionMaker());
        }
    }
    ```
- 분리를 통해 중복 문제를 해결할 수 있다.
    ```java
    public class DaoFactory {
  
        public UserDao userDao() {
            return new UserDao(connectionMaker());
        }
  
        public AccountDao accountDao() {
            return new AccountDao(connectionMaker());
        }
  
        public MessageDao messageDao() {
            return new MessageDao(connectionMaker());
        }
  
        public ConnectionMaker connectionMaker() {
            return new DConnectionMaker();
        }
    }
    ```

### 1.4.3 제어권의 이전을 통한 제어관계 역전

- 제어의 역전이란 프로그램의 제어 흐름 구조를 뒤바꾸는 것이다.
    - 일반적인 흐름
        - 프로그램 시작 지점, 사용할 객체 결정, 객체 생성, 관계 설정, 메서드 호출 등의 작업이 반복된다.
    - 제어의 역전 흐름
        - 객체 자신이 사용할 객체를 스스로 선택, 생성 하지 않는다.
        - 자신도 어떻게 만들어지고 어디서 사용되는지 알 수 없다.
        - 모든 제어권한을 자신이 아닌 다른 대상에게 위임한다.
        - 모든 객체가 이렇게 위임받은 제어 권한을 갖는 특별한 객체에 의해 결정되고 만들어진다.
    - 제어의 역전이 적용된 예
        - 서블릿
            - 서블릿에 대한 제어 권한을 가진 컨테이너에 의해 실행된다.
        - 템플릿 메소드 패턴
            - 추상 `UserDao`를 상속한 서브클래스는 `getConnection()`이 언제 어떻게 사용될지 자신은 모른다.
            - 상위 `UserDao`가 제어의 권한을 가진다.
        - 프레임워크
            - 라이브러리는 에플리케이션 코드가 직접 흐름을 제어하는 중에 필요한 기능이 있을때 능동적으로 라이브러리를 호출한다.
            - 프레임워크는 거꾸로 에플리케이션 코드가 프레임워크에 의해 사용된다.
        - `UserDao`
            - 제어의 권한을 `DaoFactory`가 가지고 있다.
            - 따라서 `DaoFactory`에서 공급해주는 객체를 받는 수동적인 존재다.
- IoC는 다양하게 사용되는 프로그래밍 모델이다.

## 1.5 스프링의 IoC

- `DaoFactory` 역할을 스프링에서는 `BeanFactory` 또는 `ApplicationContext` 라고 부른다.
- `DaoFactory` 기능을 좀 더 일반화한 것이다.

### 1.5.1 오브젝트 팩토리를 이용한 스프링 IoC

- 애플리케이션 컨텍스트와 설정정보
    - 애플리케이션 컨텍스트는 별도의 정보를 참고해서 빈의 생성, 관계설정 등의 제어 작업을 총괄한다.
    - 설정정보는 애플리케이션 로직을 담당하지는 않지만 IoC 방식을 이용해 애플리케이션 컴포넌트를 생성하고, 사용할 관계를 맺어주는 등의 책임을 담당한다.
- `DaoFactory`를 사용하는 애플리케이션 컨텍스트(소스 참고)
    - `@Configuration`: 애플리케이션 컨텍스트 또는 빈 팩토리가 사용할 설정정보라는 표시
    - `@Bean`: 객체 생성을 담당하는 IoC용 메서드라는 표시

### 1.5.2 애플리케이션 컨텍스트의 동작방식

- 오브젝트 팩토리에 대응되는 것이 스프링의 애플리케이션 컨텍스트다.
    - IoC 컨테이너 또는 빈 팩토리라고 불린다.
- 애플리케이션 컨텍스트를 사용했을 때 장점
    - 클라이언트가 구체적인 팩토리 클래스를 알 필요가 없다.
        - 클라이언트가 필요한 객체를 가져올 때, 특정 팩토리 클래스를 사용해야 한다.
        - 애플리케이션 컨텍스트를 사용하면 아무리 팰토리 클래스가 많아져도 직접 사용할 필요가 없다.
        - 일관된 방식으로 원하는 객체를 가져올 수 있다.
    - 애플리케이션 컨텍스트는 종합 IoC 서비스를 제공해준다.
        - 단순히 객체 생성, 관계설정 만 해주는 것이 아니다.
        - 객체가 만들어지는 방식, 시점과 전략을 다르게 가져갈 수도 있고, 자동생성, 생성후 후처리, 정보의 조합, 설정 방식의 다변화, 인터셉팅 등 효과적으로 활용할 수 있는 다양한 기능을 제공한다.
    - 애플리케이션 컨텍스트는 빈을 검색하는 다양한 방법을 제공한다.
        - 빈의 이름, 타입, 애토테이션 설정 등을 이용해 빈을 찾을 수 있다.

### 1.5.3 스프링 IoC의 용어 정리

- 빈(Bean)
    - 스프링이 IoC 방식으로 관리하는 오브젝트(Managed Object)
    - 스프링이 직접 그 생성과 제어를 담당하는 객체만을 빈이라고 한다.
- 빈 팩토리(Bean Factory)
    - 스프링의 IoC 를 담당하는 핵심 컨테이너
    - 빈을 등록, 생성, 조회, 그 외 부가적인 빈을 관리하는 기능을 담당한다.
    - `BeanFactory`라고 붙여쓰면 빈 팩토리를 구현하고 있는 가장 기본적인 인터페이스의 이름이 된다.
- 애플리케이션 컨텍스트(ApplicationContext)
    - 빈 팩토리를 확장한 IoC 컨테이너
    - 스프링이 제공하는 각종 부가 서비스를 추가로 제공한다.
    - `ApplicationContext`라고 적으면 애플리케이션 컨텍스트가 구현해야 하는 기본 인터페이스를 가르킨다.
- 설정정보/설정 메타정보(Configuration metadata)
    - 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용하는 메타정보
    - 컨테이너의 어떤 기능을 설정하거나 조정하는 경우에도 사용되고, IoC 컨테이너에 의해 관리되는 애플리케이션 객체를 생성하고 구성할때 사용한다.
- 컨테이너(Container) 또는 IoC 컨테이너
    - IoC 방식으로 빈을 관리한다는 의미에서 컨테이너 또는 IoC 컨테이너라고 한다.
    - 컨테이너는 애플리케이션 컨텍스트보다 추상적인 표현이기도 하다.
- 스프링 프레임워크
    - 스프링이 제공하는 모든 기능을 통틀어 지칭

## 1.6 싱글톤 레지스트리와 오브젝트 스코프

> 오브젝트의 동일성과 동등성
> - 동일성(Identity): 두 개의 객체가 완전히 같다.
> - `==` 연산자 사용
> - 동등성(Equality): 동일한 정보를 담고 있다.
> - `equals()` 메서드 사용

- `DaoFactory.userDao()`를 사용하면 매번 새로운 객체가 생성된다.
- 스프링 컨텍스트로부터 가져온 객체는 매번 동일한 객체다.

### 1.6.1 싱글톤 레지스트리로서의 애플리케이션 컨텍스트

- 애플리케이션 컨텍스트는 별 다른 설정이 없으면 내부에서 생성하는 빈 객체를 모두 싱글톤으로 만든다.

- 서버 애플리케이션과 싱글톤
    - 스프링은 초당 수십에서 수백번 클라이언트 요청을 받아 처리하는 자바 엔터프라이즈 기술을 사용하는 서버 환경에서 주로 적용되기 때문이다.
    - 하나의 요청을 처리하기 위해 다양한 기능을 담당하는 객체들이 계층형 구조로 이루어져 있다.
    - 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 객체를 새로 만들어서 사용하면 서버에 많은 부하가 걸린다.
    - 사용자의 요청을 담당하는 여러 쓰레드에서 하나의 객체를 공유해 사용하는 싱글톤 패턴의 원리를 사용한다.

> 싱글톤 패턴(Singleton Pattern)
>
> - 특정 클래스를 애플리케이션 내에서 하나의 인스턴스만 존재하도록 강제하는 패턴
> - 이렇게 만들어진 인스턴스는 애플리케이션 내에서 전역적으로 접근이 가능하다.

- 싱글톤 패턴의 한계
    - private 생성자를 갖고 있기 때문에 상속할 수 없다.
    - 싱글톤은 테스트하기 힘들다.
    - 서버환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
    - 싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다.
- 싱글톤 레지스트리(Singleton Registry)
    - 스프링은 싱글톤 패턴의 단점을 극복하기 위해 직접 싱글톤 형태의 객체를 만들고 관리한다.
        - public 생성자를 가질 수 있다.
        - 평범한 자바 클래스이기 때문에 테스트가 용이하다.
    - 스프링에서는 특별한 설정이 없다면 `getBean()`을 여러번 호출해도 매번 같은 객체를 반환한다.
- 스프링은 IoC 컨테이너일 뿐만 아니라, 고전적인 싱글톤 패턴을 대신해 싱글톤을 만들고 관리해주는 싱글톤 레지스트리이다.

### 1.6.2 싱글톤과 오브젝트의 상태

- 기본적으로 싱글톤이 멀티스레드 환경에서 서비스 형태의 객체로 사용되는 경우 무상태(Stateless) 방식으로 만들어져야 한다.
    - 다중 사용자의 요청을 한꺼번에 처리하는 스레드들이 동시에 싱글톤 객체의 인스턴스 변수를 수정하는 것은 위험하다.
    - 저장할 공간이 하나뿐이라서 서로 값을 덮어쓰고 자신이 저장하지 않은 값을 읽어올 수 있다.
    - 초기화 시점에 인스턴스 변수에 저장한 읽기 전용의 값을 공유하는 것은 문제가 없다.
    - 파라미터, 로컬변수, 리턴 값을 통해 상태 값을 이용할 수 있다.
        - 매번 새로운 값을 저장할 독립적 공간이 만들어지기 때문에 스레드가 변수의 값을 겊어쓸 일이 없다.

### 1.6.3 스프링 빈의 스코프

- 스프링이 관리하는 객체가 생성되고, 존재하고, 적용되는 범위를 빈의 스코프(scope)라고 한다.
    - 스프링 빈의 기본 스코프는 싱글톤이다.
    - 스코프의 종류
        - 프로토 타입(Prototype): 빈을 컨테이너에 요청할 때마다 매번 새로운 객체 생성
        - 요청(Request): HTTP 요청이 생길 때마다 생성
        - 세션(Session): 웹의 세션과 유사

## 1.7 의존관계 주입(DI)

### 1.7.1 제어의 역전(IoC)과 의존관계 주입

- 의존관계 주입은 스프링 IoC 기능의 대표적인 동작원리다.

> DI(Dependency Injection)
>
> 오브젝트 레퍼런스를 외부로부터 제공(주입)받고 이를 통해 여타 객체와 다이나믹하게 의존관계가 만들어지는 것

### 1.7.2 런타임 의존관계 설정

- 의존관계란 의존 대상이 변하면 그 영향을 받는 관계를 말한다.
- 의존관계는 방향성이 있어, A가 B에 의존해도 B는 A에 영향을 받지 않는다.
- `UserDao`의 의존관계
    - `UserDao`는 `ConnectionMaker`에 의존하고 있기 때문에 `ConnectionMaker` 인터페이스가 변한다면 영향 받는다.
    - 하지만 `ConnectionMaker` 인터페이스를 구현한 클래스를 변경하거나, 내부에 메서드에 변화가 생겨도 `UserDao`에 영향을 주지 않는다.
    - 인터페이스에 대해서만 의존관계를 만들어두면 구현 클래스와의 관계는 느슨해진다.
    - 느슨한 의존관계를 갖는 경우 런타임 시에 실제 사용 대상인 의존 오브젝트(Dependent Object)와 관계가 맺어진다.
    - 의존관계 주입의 3가지 조건
        - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 그러기 위해서는 인터페이스에만 의존해야 한다.
        - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정한다.
        - 의존관계는 사용할 객체에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.
- `UserDao`의 의존관계 주입(소스 참고)

### 1.7.3 의존관계 검색과 주입

- 의존관계 검색(Dependency Lookup)
    - 외부로부터의 주입이 아니라 스스로 검색을 통해 의존관계를 맺는 방법
    - 자신이 필요로 하는 의존 오브젝트를 능동적으로 찾는다.
    - 자신이 어떤 클래스의 객체를 이용할지 결정하지 않는다.
    - 런타임 시 의존관계를 맺을 객체를 결정하는 것과 객체의 생성작업은 외부 컨테이너에게 IoC로 맡긴다.
    - 의존관계를 가져오는 메소드나 생성자를 통한 주입 대신 스스로 컨테이너에 요청하는 방법응 사용한다.
- 의존관계 주입과 의존관계 검색
  - DI를 통해 객체를 주입받을 수 없는 상황에서는 의존관계 검색을 사용해야 한다.
  - 의존관계 주입 받는 객체와 의존 객체 모두 스프링 빈이어야 한다.
  - 의존관계 검색하는 객체가 스프링 빈일 필요는 없다.

### 1.7.4 의존관계 주입의 응용

- 기능 구현의 교환
    - DI 설정 정보를 통해 다양한 환경에서 목적에 맞는 `ConnectionMaker`를 사용할 수 있다.
- 부가 기능 추가
    - DAO에서 DB를 연결한 수를 카운트하는 기능이 필요한 경우 DI를 통해 데코레이터 패턴(Decorator Pattern)을 적용하면 기존 코드 수정없이 구현할 수 있다.(소스 참고)
        - 관심사를 분리할 수 있다.
            - DB 연결한 수 카운트 로직은 `CountingConnectionMaker`의 책임이다.
        - 설정 정보만 수정하면 의존관계를 변경할 수 있기 때문에 개방-폐쇄 원칙을 지킬 수 있다.

### 1.7.5 메소드를 이용한 의존관계 주입

- 의존관계를 주입하는 3가지 방법
    - 생성자
    - 수정자 메소드를 이용한 주입
        - 수정자(Setter) 메서드를 통해 외부에서 객체 내부의 설정 값을 변경하는 방법이다.
        - 제약 조건
            - 메서드 이름은 set으로 시작해야 한다.
            - 한 번에 한 개의 파라메터만 가질 수 있다.
    - 일반 메소드를 이용한 주입
        - 여러 개의 파라미터를 갖을 수 있다.
            - 파라미터의 개수가 많고, 비슷한 타입이 여러 개라면 실수하기 쉽다.

## 1.8 XML을 이용한 설정

- DI 의존관계 설정정보
    - `DaoFactory`와 같은 자바 클래스 이용 방식
    - XML 설정 방식
        - 단순한 텍스트라 다루기 쉽다.
        - 자바 컴파일과 같은 빌드가 필요 없다.
        - 빠르게 변경사항을 반영할 수 있다.

### 1.8.1 XML 설정

- 하나의 `@Bean` 메서드를 통해 얻을 수 있는 정보
    - 빈의 이름: `getBean()`에서 사용된다.
    - 빈의 클래스: 빈 객체를 어떤 클래스를 이용해서 만들지 정의
    - 빈의 의존 오브젝트
      - 빈의 생성자, 수정자 메소드를 통해 의존 객체를 넣어준다.
      - 의존 객체도 하나의 빈이므로 이름이 있을 것이고, 그 이름에 해당하는 메소드를 호출하여 의존 객체를 가져온다.
- `connectionMaker()` 전환(소스 참고)

|        | 자바 코드 설정정보              | XML 설정정보                  |
|--------|-------------------------|---------------------------|
| 빈 설정파일 | @Configuration          | <beans>                   |
| 빈의 이름  | @Bean methodName()      | <bean id="methodName"     |
| 빈의 클래스 | return new BeanClass(); | clsss="a.b.c...BeanClass> |

- `userDao()` 전환(소스 참고)
- XML의 의존관계 주입 정보(소스 참고)

### 1.8.2 XML을 이용하는 애플리케이션 컨텍스트

- XML 설정정보를 이용하는 IoC/DI 작업에는 `GenericXmlApplicationContext`를 사용한다.
    - 생성자 파라미터로 XML 파일의 클래스패스를 지정한다.
      - 클래스패스가 `/`로 시작하면 코드가 실행되는 패키지를 기준으로 찾는다.
      - `/`로 시작하지 않는 경우 루트에서부터 시작한다.   
- `ClassPathXmlApplicationContext`는 클래스패스에 있는 클래스 객체를 넘겨서 힌트를 제공할 수 있다.
- 특별한 이유가 없다면 `GenericXmlApplicationContext` 사용을 권장한다.

### 1.8.3 `DataSource` 인터페이스로 전환

- 스프링에서는 `ConnectionMaker`와 같은 역할을 `DataSource`를 통해 제공한다.
- `DataSource`의 구현체들은 이미 구현되어 있고, 안정적이다.
- 자바 코드 설정 방식(소스 참고)
- XML 설정 방식(소스 참고)

### 1.8.4 프로퍼티 값의 주입

- 값 주입
    - 객체 뿐만 아니라 `String` 같은 단순 값을 넣어줄 수 있다.
    - 수정자 메서드를 통해 값을 넣어주는 것을 스프링에서는 "값을 주입한다"고 한다.
    - JavaConfig 방식
    ```java
    dataSource.setDriverClass(com.mysql.jdbc.Driver.class);
    dataSource.setUrl("jdbc:mysql://localhost:3306/study");
    dataSource.setUsername("root");
    dataSource.setPassword("1q2w3e4r!");
    ```
    - XML 방식
    ```xml
    <property name="driverClass" value="com.mysql.jdbc.Driver"/>
    <property name="url" value="jdbc:mysql://localhost:3306/study"/>
    <property name="username" value="root"/>
    <property name="password" value="1q2w3e4r!"/>
    ```
- value 값의 자동 변환
    - 스프링은 value에 지정한 텍스트 값을 적절한 자바 타입으로 변환해준다.
    
## 1.9 정리

- 먼저 책임이 다른 코드를 분리하여 두 개의 클래스로 만들었다(관심사의 분리, 리팩토링).
- 그중에서 바뀔 수 있는 쪽의 클래스는 인터페이스를 구현하도록 하고，다른 클래스에서 인터페이스를 통해서만 접근하도록 만들었다. 이렇게 해서 인터페이스를 정의한 쪽의 구현 방법이 달라져 클래스가 바뀌더라도, 그 기능을 사용하는 클래스의 코드는 같이 수정할 필요가 없도록 만들었다(전략 패턴).
- 이를 통해 자신의 책임 자체가 변경되는 경우 외에는 불필요한 변화가 발생하지 않도록 막아주고，자신이 사용하는 외부 오브젝트의 기능은 자유롭게 확장하거나 변경할 수 있게 만들었다(개방 폐쇄 원칙).
- 결국 한쪽의 기능 변화가 다른 쪽의 변경을 요구하지 않아도 되게 했고(낮은 결합도), 자신의 책임과 관심사에만 순수하게 집중하는(높은 응집도) 깔끔한 코드를 만들 수 있었다.
- 객체가 생성되고 여타 객체와 관계를 맺는 작업의 제어권을 별도의 오브젝트 팩토리를 만들어 넘겼다. 또는 오브젝트 팩토리의 기능을 일반화한 IoC 컨테이너로 넘겨서 객체가 자신이 사용할 대상의 생성이나 선택에 관한 책임으로부터 자유롭게 만들어줬다(제어의 역전/IoC).
- 전통적인 싱글톤 패턴 구현 방식의 단점을 살펴보고, 서버에서 사용되는 서비스 객체로서의 장점을 살릴 수 있는 싱글톤을 시용하면서도 싱글톤 패턴의 단점을 극복할 수 있도록 설계된 컨테이너를 활용하는 방법에 대해 알아봤다(싱글톤 레지스트리).
- 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어놓고, 런타임 시에 실제 사용할 구체적인 의존 객체를 제3자(DI 컨테이너)의 도움으로 주입받아서 다이나믹한 의존관계를 갖게 해주는 IoC의 특별한 케이스를 알아봤다(의존관계 주입/DI).
- 의존 객체를 주입할 때 생성자를 이용하는 방법과 수정자 메소드를 이용하는 방법을 알아봤다(생성자 주입과 수정자 주입).
- 마지막으로, XML을 이용해 DI 설정정보를 만드는 방법과 의존 객체가 아닌 일반 값을 외부에서 설정해서 런타임 시에 주입하는 방법을 알아봤다(XML 설정).


- 스프링이란 "어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크"이다.
- 스프링의 관심은 객체와 그 관계다.
- 하지만 객체를 어떻게 설계하고, 분리하고, 개선하고, 어떤 의존관계를 가질지 결정하는 일은 개발자의 역할이며 책임이다.
- 스프링은 원칙을 잘 따르는 설계를 적용하려고 할 때 도와주는 도구일 뿐이다.
