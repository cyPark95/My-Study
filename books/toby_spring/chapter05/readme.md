# 5장 서비스 추상화

- 자바에는 사용 방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다.
- 5장에서는 지금까지 만든 DAO에 트랜잭션을 적용해보면서 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지 살펴본다.

## 5.1 사용자 레벨 관리 기능 추가

- 지금까지 `UserDao`는 기초적인 CRUD(Create-Read-Update-Delete) 작업만 가능하다.
- 사용자 관리 기능을 추가한다.
    - 사용자의 레벨은 `BASIC`, `SILVER`, `GOLD` 세 가지 중 하나다.
    - 사용자가 처음 가입하면 `BASIC` 레벨이 되며, 이후 활동에 따라서 한 단계씩 업그레이드될 수 있다.
    - 가입 후 50회 이상 로그인을 하면 `BASIC`에서 `SILVER` 레벨이 된다.
    - SILVER 레벨이면서 30번 이상 추천을 받으면 `GOLD` 레벨이 된다.
    - 사용자 레벨의 변경 작업은 일정한 주기를 가지고 일괄적으로 진행된다. 변경 작업 전에는 조건을 충족하더라도 레벨의 변경이 일어나지 않는다.

### 5.1.1 필드 추가

- 사용자의 레벨을 저장하기 위한 필드로 각 레벨을 코드화해서 숫자로 저장하면 DB 용량도 덜 차지하고, 가벼운 장점이 있다.
    - `User`에 추가할 Level 타입을 정수로 지정한다면 다음과 같은 문제들이 발생할 수 있다.
      ```java
      public class User {
      
          private static final int BASIC = 1;
          private static final int SILVER = 2;
          private static final int GOLD = 3;
          
          private int level;
          
          public void setLevel(int level) {
              this.level = level;
          }
      }
      ```
        - 다른 종류의 정보를 넣는 실수를 해도 컴파일러가 체크해주지 못한다.
            ```java
            user.setLevel(other.getSum());
            ```
        - 범위를 벗어나는 값을 넣어도 컴파일러가 체크해주지 못한다.
            ```java
            user.setLevel(1000);
            ```
    - Java의 Enum을 활용하면 위 문제들을 해결할 수 있다.
    - `Level` Enum 내부에는 DB에 저장할 정수 타입의 값을 가지고 있지만, 객체이기 때문에 타입이 일치하지 않으면 컴파일러가 체크해서 걸러준다.
- `User` 필드 추가(소스 참고)
- `UserDaoTest` 테스트 수정(소스 참고)
    - 기존 코드에 새로운 기능을 추가할 때는 테스트를 먼저 만드는 것이 안전하다.
    - `User` 객체의 필드 비교 로직을 `checkSameUser()` 메서드를 통해 일정하게 유지할 수 있다.
- `UserDaoJdbc` 수정(소스 참고)
    - `Level` Enum은 오브젝트로, DB에 저장/조회 시 타입 변환이 필요하다.
    - JDBC가 사용하는 SQL은 컴파일 과정에서 자동으로 검증되지 않는 단순 문자열이다.
    - 실제 DB에 전달되기 전까지 문법 오류나 오타를 발견하기 힘들다.
    - 이러한 상황에서 DB까지 연동되는 포괄적인 테스트는 위력을 발휘한다.

### 5.1.2 사용자 수정 기능 추가

- 수정 기능 테스트 추가(소스 참고)
    - 테스트 메소드가 실행될 때마다 `UserDaoTest`는 새로 만들어지기 때문에, 테스트 픽스처 인스턴스를 직접 변경해도 상관 없다.
- `UserDao`와 `UserDaoJdbc` 수정(소스 참고)
  > 테스트를 먼저 만들면, 아직 생성되지 않은 클래스나 메서드를 먼저 사용하는 경우가 있다.
  > 이 경우 IDE의 자동 수정 기능을 활용해서 생성하면 오타도 막아주고, 편리하다.
- 수정 테스트 보완
    - JDBC 개발에서 가장 많은 실수가 일어나는 곳은 SQL 문장이다.
        - UPDATE 문장에서 WHERE 절이 없어도 정상적으로 동작하는것 처럼 보인다.
    - 해결 방법
        - `JdbcTemplate`의 `update()` 반환 값을 통해 SQL을 통해 영향 받은 Row의 수를 확인한다.
        - 테스트를 보강하여 변경하려는 사용자 외의 정보는 변경되지 않았음을 직접 확인한다.(소스 참고)
            - 사용자를 두 명 등록하고, 그 중 하나만 수정한 뒤 수정된 사용자와 수정하지 않은 사용자의 정보 모두 확인하는 방법이다.

### 5.1.3 UserService.updateLevels()

- DAO는 데이터 어떻게 가져오고 조작할지를 다루는 곳으로 비즈니스 로직을 두기에는 적당하지 않다.
- 비즈니스 로직을 담을 클래스를 추가하고. 서비스를 제공한다는 의미에에서 `UserService`로 한다.
- `UserService` 클래스와 빈 등록(소스 참고)
- `upgradeLevels()` 메서드(소스 참고)

### 5.1.4 UserService.add()

- 처음 가입하는 사용자는 기본적으로 BASIC 레벨이어야 한다는 로직은 어디에 담는 것이 좋을까?
    - `UserDaoJdbc.add()`는 적합하지 않다.
        - `UserDaoJdbc`는 User 객체를 DB에 저장하고, 조회하는 관심만 가져야 한다.
    - `User` 객체에서 `level` 필드를 `Level.BASIC`으로 초기화 하는 방법
        - 처음 가입할 때를 제외하면 무의미한 정보인데, 단지 이 로직을 담기위해 클래스에 직접 초기화 하는 것은 문제가 있다.
    - `UserService`에도 `add()`를 만들고, 필요한 비즈니스 로직을 담당하게 한다.
- `UserService.add()` 테스트 작성(소스 참고)
- `UserService.add()` 메서드 작성(소스 참고)

### 5.1.5 코드 개선

> 작성된 코드를 상펴볼 때 필요한 질문
>
>- 코드에 중복된 부분은 없는가?
>- 코드가 무엇을 하는 것인지 이해하기 불편하지 않은가?
>- 코드가 자신이 있어야할자리에 있는가?
>- 앞으로 변경이 일어난다면 어떤 것이 있을 수 있고，그 변화에 쉽게 대응할 수 있게 작성되어 있는가?

- `upgradeLevels()` 메서드 코드의 문제점
    ```java
        public void upgradeLevels() {
            List<User> users = userDao.getAll();
    
            for(User user: users) {
                boolean changed;
                if(user.getLevel() == Level.BASIC && user.getLogin() >= 50) {
                    user.setLevel(Level.SILVER);
                    changed = true;
                } else if(user.getLevel() == Level.SILVER && user.getRecommend() >= 30) {
                    user.setLevel(Level.GOLD);
                    changed = true;
                } else if(user.getLevel() == Level.GOLD) {
                    changed = false;
                } else {
                    changed = false;
                }
    
                if(changed) {
                    userDao.update(user);
                }
            }
        }
    ```
    - for 루프 속 if/elseif/else 블록들에 여러 로직들이 한데 섞여 있어 로직을 이해하기 어렵다.
        - 무엇인지 파악하는 로직
        - 업그레이드 조건을 담은 로직
        - 다음 단계의 레벨과 업그레이드 조건이 충족됐을 때 해야 할 작업
        - DB에 update 하는 로직
    - if 조건 블록이 레벨 개수만큼 반복된다.
        - 레벨이 추가되면 `Level` Enum도 수정해야 한다.
        - `upgradeLevels()`에서 if 조건식과 블록을 추가해야 한다.
        - 업그레이드 조건이 복잡해지면 `upgradeLevels()` 메서드는 점점 길어지고 복잡해지며, 갈수록 이해하고 관리하기 힘들어진다.
        - 버그가 숨어있을 가능성이 높아진다.
    - 현재 레벨과 업그레이드 조건을 동시에 비교하기 때문에 성격이 다른 두 가지 경우 모두 else 블록에서 처리하고 있다.
    - 변화에 취약하고, 다루기 힘든 코드다.
- `upgradeLevels()` 리팩토링(소스 참고)
    - 비즈니스 로직 추상화를 통해 어떤 작업을 하는지 쉽게 이해할 수 있다.
        - 전체 사용자를 조회한다.
        - 한 명씩 레벨 업그레이드 가능 여부를 확인한다.
        - 가능하면 업그레이드한다.
    - 각 객체의 책임을 분리한다.
        - `Level` Enum에서 레벨의 업그레이드 순서를 관리한다.
        - `User` 객체에서 내부 정보 변경 로직을 관리한다.
- 객체에게 데이터를 요구하기보다 작업을 요청하는 것이 객체지향 프로그램의 기본 원리이다.
- `User` 테스트(소스 참고)
- `UserServiceTest` 개선(소스 참고)
    - 테스트 로직이 분명하게 드러난다.

## 5.2 트랜잭션 서비스 추상화

- 레벨 관리 작업 수행 도중에 문제가 발생해서 작업이 중단된다면 그때까지 변경된 사용자의 레벨 모두 취소시켜야 한다면?

### 5.2.1 모 아니면 도

- 테스트용 `UserService` 대역
    - 작업 중간에 예외가 발생하는 상황을 테스트 하기위해 `UserService`의 대역을 사용한다.
        - 테스트를 위해 애플리케이션 코드를 수정하는 것은 좋은 생각이 아니다.
    - `UserService`를 상속해서 테스트에 필요한 기능을 추가하도록 일부 메서드를 재정의하는 방법을 사용한다.
- 강제 예외 발생을 통한 테스트(소스 참고)
    - 현재 작업 중간에 예외가 발생해도 그대로 유지되고 있기 때문에 테스트가 실패한다.
- 테스트 실패의 원인
    - `upgradeLevels()` 메서드가 하나의 트랜잭션 안에서 동작히지 않기 때문이다.
    - 트랜잭션이란 더 이상 나눌 수 없는 단위 작업을 말한다.
    - 전체가 성공하거나 전체가 실패하기 위해선 트랜잭션이 적용되야 한다.

### 5.2.2 트랜잭션 경계설정

- DB는 하나의 SQL 명령을 처리하는 경우 트랜잭션을 보장해준다.
- 여러 개의 SQL이 하나의 트랜잭션으로 취급해야 하는 경우는?
    - 여러 SQL 작업 수행 도중에 문제가 발생해 작업이 중단된다면 앞에서 처리한 SQL 작업도 취소시켜야 한다.
        - 이런 취소 작업을 트랜잭션 롤백(Transaction Rollback)이라고 한다.
    - 모든 SQL 수행 작업이 모두 성공적으로 마무리 됐다고 DB에 알려줘서 작업을 확정시켜야 한다.
        - 이것을 트랜잭션 커밋(Transaction Commit)이라고 한다.
- JDBC 트랜잭션의 트랜잭션 경계설정
    - 트랜잭션은 시작하는 지점과 끝나는 지점이 있고, 트랜잭션의 경계라고 한다.
    - 트랜잭션 시작 방법은 한 가지지만 끝나는 방법은 롤백과 커밋 두 가지다.
    - 비즈니스 로직의 흐름 사이에서 트랜잭션 경계를 설정하는 일은 중요한 작업이다.
    ```java
    Connection connection = dataSource.getConnection();
        
    connection.setAutoCommit(false);
    try {
        // SQL 작업
        connection.commit();
    } catch (Exception e) {
        connection.rollback();
    } finally {
        connection.close();
    }
    ```
    - `setAutoCommit(false)`로 시작하고, `commit()` 또는 `rollback()`으로 종료되는 작업을 트랜잭션의 경계설정(Transaction Demarcation)이라고 한다.
- `UserService`와 `UserDao`의 트랜잭션 문제
    - `UserService.upgradeLevels()`에는 트랜잭션 경계설정 코드가 없기 때문에 트랜잭션이 적용되지 않았다.
    - `JdbcTemple`은 템플릿 메서드 안에서 `Connection` 객체를 관리하기 때문에 메서드마다 독립적인 트랜잭션으로 실행된다.
- 비즈니스 로직 내의 트랜잭션 경계설정
    - 여러 번 DB에 업데이트하는 작업을 하나의 트랜잭션으로 만들려면 어떻게 해야하는가?
        - DAO 메서드 안으로 `upgradeLevels()` 메서드를 옮기는건 비즈니스 로직과 데이터 로직이 혼재되어 확장성을 떨어트린다.
        - 트랜잭션 경계설정의 작업을 `UserService`로 가져와야 한다.
            - `UserDao`가 가진 데이터 엑세스 코드는 최대한 남겨둔 채로, `UserService`에는 트랜잭션의 시작과 종료만 담당하는 최소한의 코드만 가져온다.
            - 이렇게 하면 책임이 다른 코드를 분리해둔 채로 트랜잭션 문제를 해결할 수 있다.
            - `UserDao.update()` 메서드는 `upgradeLevels()` 메서드에서 만든 `Connection`을 사용해야 한다.
- `UserService` 트랜잭션 경계설정의 문제점
    - `JdbcTemplate`을 더 이상 활용할 수 없다.
    - DAO와 `UserService`의 메서드에 `Connection` 파라미터가 추가돼야 한다.
    - `Connection` 파라미터로 인해 `UserDao` 인터페이스는 더 이상 데이터 엑세스 기술에 독립적일 수 없다.
    - 테스트 코드에도 `Connectionn` 객체를 일일이 만들어서 DAO 메서드를 호출하도록 변경해야 한다.

### 5.2.3 트랜잭션 동기화

- 스프링에서는 트랜잭션 경계를 설정해 관리하기 위한 방법을 제공해준다.
- `Connection` 파라미터 제거
    - 스프링에서는 독립적인 트랜잭션 동기화(Transaction Synchronization) 방식을 통해 `Connection`을 파라미터로 전달하는 문제를 해결한다.
        - 트랜잭션 동기화는 `Connection` 객체를 특별한 저장소에 보관해두고, 이 후 호출되는 DAO 메서드에서 저장된 `JdbcTemplate`이 가져다 사용하는 방식이다.
            - `UserService`는 `Connection`을 생성한다.
            - 생성한 `Connection`을 트랜잭션 동기화 저장소에 저장하고, `Connection.setAutoCommit(false)`를 호출해 트랜잭션을 실행시킨다.
            - `update()` 메서드가 호출되는 과정에서 `JdbcTemplate`는 트랜잭션 동기화 저장소에 저장된 `Connection` 객체가 존재하는지 확인한다.
            - 저장된 `Connection`을 가져와서 `PreparedStatement`를 만들어 수정 SQL을 실행한다.
            - 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때, `JdbcTemplate`은 `Connection`을 닫지 않을 채로 작업을 마친다.
            - 트랜잭션 내의 모든 작업이 정상적으로 끝나면 `UserService`는 `Connection`의 `commit()`을 호출해서 트랜잭션을 완료 시킨다.
            - 트랜잭션 저장소가 더 이상 `Connection` 객체를 저장해두지 않도록 제거한다.
            - 어느 작업 중에라도 예외상황이 발생하면 `UserService`는 즉시 `Connection.rollback()`을 호출하고 트랜잭션을 종료할 수 있다.
- 트랜잭션 동기화 적용(소스 참고)
    - 스프링은 `TransactionSynchronizationManager` 클래스를 통해 트랜잭션 동기화 관리를 제공한다.
- 트랜잭션 테스트 보완(소스 참고)
- `JdbcTemplate`과 트랜잭션 동기화
    - `JdbcTemplate`이 제공해주는 세 가지 유용한 기능
        - `try/catch/finally` 작업 흐름 지원
        - `SQLException` 예외 변환
        - 트랜잭션 동기화를 시작해 둔 경우 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어있는 DB 커넥션을 가져와 사용한다.

### 5.2.4 트랜잭션 서비스 추상화

- 지금까지의 `UserService`와 `UserDao`, `UserDaoJdbc`는 JDBC API를 사용하고 트랜잭션을 적용했으며, 책임과 성격에 따라 데이터 액세스 부분과 비즈니스 로직을 분리, 유지할 수 있게
  만든 코드다.
- 기술과 환경의 종속되는 트랜잭션 경계설정 코드
    - 하나의 트랜잭션 안에서 여러 개의 DB에 데이터를 저장하는 작업이 필요하다면?
        - JDBC의 `Connection`을 이용한 트랜잭션 방식은 DB Connection에 종속된 로컬 트랜잭션이다.
        - 글로벌 트랜잭션(Global Transaction) 방식을 사용해야 한다.
    - Java는 글로벌 트랜잭션을 지원하기 위한 API인 JTA(Java Transaction API)를 제공한다.(JTA는 11장에서 자세히 알아볼 예정)
- 트랜잭션 API의 의존관계 문제와 해결책
    - `UserService`에서 `Connection`을 이용해 트랜잭션 경계설정 코드로 인해 JDBC에 종속적인 코드가 돼버렸다.
    - 해결 방법
        - 트랜잭션 경계설정 코드는 일정한 패턴을 가지고 있기 때문에 추상화를 생각해볼 수 있다.
        - 추상화란 하위 시스템의 공통점을 뽑아내서 분리시는 것을 말한다.
        - 추상화를 통해 하위 시스템에 대한 의존성을 분리할 수 있다.
- 스프링의 트랜잭션 서비스 추상화(소스 참고)
    - 스프링은 `PlatformTeasactionManage` 인터페이스를 통해 트랜잭션 추상화 기술을 제공한다.
    - 시작된 트랜잭션은 `TrasactionStatus` 타입의 변수에 저장된다.
- 트랜잭션 기술 설정의 분리(소스 참고)
    - `JtaTrasactionManager`는 서버의 트랜잭션 서비스를 이용하기 때문에 `DataSource`도 서버가 제공해주는 것을 사용해야 한다.

## 5.3 서비스 추상화와 단일 책임 원칙

- 이제 설정을 수정하는 것만으로 DB 연결 기술, 데이터 액세스 기술, 트랜잭션 기술을 자유롭게 바꿔서 사용할 수 있는 구조가 됐다.
- 수직, 수평 계층구조와 의존관계
    - 추상화 기법을 통해 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.
    - 수평적 분리
        - `UserDao`와 `UserService`는 같은 계층에서 담당하는 코드와 기능적인 관심사에 따라 분리된다.
    - 수직적 분리
        - `UserDao`와 DB 연결 기술, `UserService`와 트랜잭션 기술과 같이 로우 레벨의 기술을 추상화를 통해 분리된다.
    - 인터페이스와 DI를 통해 연결됨으로써 결합도가 낮다.
    - 결합도가 낮은 코드는 로우 레벨의 기술 서비스와 환경에서 독립시켜준다.
    - DI의 가치는 관심, 책임, 성격이 다른 코드를 분리하는 데 있다.
- 단일 책임 원칙(Single Responsibility Principle)
    - 하나의 모듈은 한 가지 책임을 가져야 한다는 의미다.
    - `UserService`는 트랜잭션 서비스의 추상화 방식과 DI를 통해 비즈니스 로직에만 집중할 수 있는, 단일 책임 원칙을 지키는 코드가 됐다.
- 단일 책임 원칙의 장점
    - 변경이 필요할 때 수정 대상이 명확해진다.
        - 비즈니스 로직 변경 시 서비스 계층만, 데이터 접근 방식 변경 시 DAO만 수정하면 된다.
        - 많은 코드를 수정할수록 실수 가능성이 높아진다.
    - 객체지향 설계와 프로그래밍의 원칙은 서로 긴밀하게 관련이 있다.
        - DI를 통해 단일 책임 원칙을 잘 지키면 자연스럽게 개발 폐쇄 원칙도 잘 지키는 코드가 된다.
            - 모듈 간 결합도가 낮아지고, 단일 책임에 집중된 응집도 높은 코드가 된다.
            - 기술 변경 시 기존 코드 변경 없이 구현체만 교체하면 된다.
    - 테스트가 용이하다.
        - DI와 싱글톤 레지스트리를 활용하면 자동화된 테스트 환경을 편리하게 구성할 수 있다.
    - 스프링에서 DI는 좋은 설계와 유연한 코드를 만드는 핵심 원리로, 객체지향 원칙과 패턴을 실현할 수 있게 해주는 가장 중요한 도구다.

## 5.4 메일 서비스 추상화

- 레벨 업그레이드 시, 안내 메일 발송 로직을 추가한다.
    - `User`에 `email` 필드 추가
    - `UserService.upgradeLevel()` 메서드에 메일 발송 기능 추가

### 5.4.1 `JavaMail`을 이용한 메일 발송 기능

- `User` 테이블, 클래스에 email 필드 추가
- `JavaMail` 메일 발송
    ```java
    private void sendUpgradeEmail(User user) {
        Properties properties = new Properties();
        properties.put("mail.smtp.host", "mail.ksug.org");
        Session session = Session.getInstance(properties, null);

        MimeMessage message = new MimeMessage(session);
        try {
            message.setFrom(new InternetAddress("useradmin@ksug.org"));
            message.addRecipient(Message.RecipientType.TO, new InternetAddress(user.getEmail()));
            message.setSubject("Upgrade 안내");
            message.setText(String.format("사용자님의 등급이 %s로 업그레이드되었습니다", user.getLevel().name()));

            Transport.send(message);
        } catch (AddressException e) {
            throw new RuntimeException(e);
        } catch (MessagingException e) {
            throw new RuntimeException(e);
        }
    }
    ```

### 5.4.2 `JavaMail`이 포함된 코드의 테스트

- 현재 테스트 문제점
    - 연결 가능한 메일 서버가 없기 때문에 테스트에 실패한다.
    - 메일 서버가 준비돼 있으면 실제로 메일이 발송된다.
        - 메일 발송은 부하가 큰 작업이므로, 테스트를 돌릴 때마다 실행하면 서버에 부담을 줄 수 있다.
- `JavaMail`과 같은 충분히 검증된 시스템은, SMTP로 정상적으로 메일 전송 요청이 전달되면 실제 수신까지 확인하지 않아도 신뢰할 수 있다.
- 테스트 가능한 메일 서버까지만 잘 전송되는지만 확인하면 된다.
- 테스트 메일 서버는 메일 전송 요청은 받지만 실제로 메일이 발송되지 않도록 구성한다.

### 5.4.3 테스트를 위한 서비스 추상화

- `JavaMail`을 이용한 테스트의 문제점
    - `JavaMail`은 확장이나 지원이 불가능하기 때문에 테스트용으로 바꿔치기할 수 없다.
        - 메시지를 만들기 위한 `Session`과 메일 메시지를 작성하는 `MailMessage`, `Transport`는 인터페이스가 아닌 클래스다.
        - 객체 생성 방법은 정적 팩토리 메서드를 이용하는 방법 뿐이다.
        - 상속이 불가능한 final 클래스다.
    - 문제를 해결하기 위해 스프링은 `JavaMail`의 추상화 기능을 제공한다.
- 메일 발송 기능 추상화(소스 참고)
    - 스프링은 `MailSender` 인터페이스를 제공한다.
        - `SimpleMailMessage` 인터페이스를 구현한 클래스에 담긴 메일 메시지를 전송한다.
        - 메일 전송 중 발생하는 각종 예외를 `MailException` 런타임 예외로 포장해서 던져준다.
- 테스트용 메일 발송 오브젝트(소스 참고)
- 테스트와 서비스 추상화
    - 추상화 계층을 통해 얻을 수 있는 장점
        - 인터페이스를 구현한 클래스만 DI 한다면 기존 코드 변경 없이 사용할 수 있다.
        - 메일을 작업 큐에 담아뒀다가 정해진 시간에 메일을 발송하는 기능을 만드는 것도 쉽다.
            - `MailSender` 인터페이스를 구현한, 메일 발송 큐의 구현을 만들고 DI를 통해 실제 메일 발송 객체를 연결해서 사용할 수 있다.
    - 메일 발송 작업에 트랜잭션 개념 적용 방법
        - 발송 대상을 별도의 목록으로 저장하고, 업그레이드 작업이 완료되면 한 번에 메일을 전송한다.
            - 메일 저장용 리스트 등 파라미터로 계속 가지고 다녀야 한다.
            - 비즈니스 로직과 기술적인 부분이 한데 섞이게 된다.
        - `MailSender`를 확장해서 메일 전송에 트랜잭션 개념을 적용한다.
            - 업그레이드 작업이 끝나면 지금까지 저장된 메일을 모두 발송하고, 예외가 발생하면 모두 취소하게 할 수 있다.
            - 서로 다른 종류의 작업이 분리해 처리하는 장점이 있다.
    - 확장이 불가능한 API를 사용해야 하는 경우라면 테스트를 위해서라도 서비스 추상화 계층의 도입을 고려해볼 필요가 있다.

### 5.4.4 테스트 대역

- `DummyMailSender` 클래스는 `MailSnder` 인터페이스를 구현해놨을 뿐 아무것도 하지 않지만, 안전하게 테스트를 실행할 수 있게 해준다.
- 스프링의 XML 설정 파일을 테스트 용으로 따로 만들면 운영 환경과 개발 환경을 분리할 수 있다.
- 의존 오브젝트의 변경을 통한 테스트 방법
    - 테스트는 대상 객체의 관심사에 초점을 맞춘 테스트가 필요하다.
        - `UserDao`의 관심사는 어떻게 동작하는지이지 DB 커넥션 풀이나 DB 자체가 아니다.
        - `UserService`의 관심사는 사용자 정보를 가공하는 비즈니스 로직에 있다.
    - 테스트 대상이 되는 객체가 다른 객체에 의존하는 일은 흔하다.
    - 의존한다는 말은 종속되거나 기능을 사용한다는 의미로, 사용하는 객체의 변경에 영향을 받을 수 있기 때문에 협력 오브젝트(Collaborator Object)라고도 한다.
    - 테스트 하는데 거창한 작업이 뒤따르는 경우, 스프링의 DI는 큰 위력을 발휘한다.
        - `UserDao` 처럼 간단한 환경으로 만들 수 있다.
        - `UserService` 처럼 아무일도 하지 않는 빈 객체로 대치해줄 수 있다.
    - 운영 환경에서 구현 클래스가 바뀌지 않는다고 하더라도, 단지 테스트를 위해서라도 인터페이스와 스프링의 DI를 적용해야 한다.
- 테스트 대역의 종류와 특징
    - 테스트 대역(Test Double)
        - 테스트 환경을 위해 기능에만 수행하면서 빠르고, 자주 테스트를 실행할 수 있도록 도와준다.
        - 테스트 스텁(Test Stub)
            - 테스트 대상이 의존하는 객체 역할을 대신한다.
            - DI 등을 통해 미리 테스트 대상에 주입되고, 테스트 코드 내부에서 간접적으로 사용된다.
            - 테스트 스텁은 필요한 정보를 반환하거나, 특정 상황에서는 예외를 발생시키도록 구현할 수 있다.
        - 목 오브젝트(Mock Object)
            - 테스트 스텁과 유사하지만, 테스트 대상과 상호작용에서 발생하는 내용을 저장해 뒀다가 테스트 결과를 검증하는 데 활용할 수 있다.
- 목 오브젝트를 이용한 테스트(소스 참고)

## 5.5 정리

- 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다. 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메서드로 정리돼야 한다.
- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI를 잘 활용해서 결합도를 낮춰줘야 한다.
- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요한다.
- 트랜잭션의 시작과 종료를 지정하는 일을 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
- 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경돼야 한다.
- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하는 특정 기술에 대한 강한 결합을 만들어낸다.
- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.
- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입한다.
- 서비스 추상화는 테스트하기 어려운 JavaMail 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.
- 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다.
- 테스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
- 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고 한다.
